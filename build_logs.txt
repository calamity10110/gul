ðŸš€ Building GUL Compiler from GUL Source
========================================

Step 1: Transpiling GUL â†’ Rust...
Found 10 GUL files to transpile
Transpiling main.mn -> main.rs
âœ… Generated main.rs
Transpiling ast/nodes.mn -> ast/nodes.rs
âœ… Generated ast/nodes.rs
Transpiling parser/parser.mn -> parser/parser.rs
âœ… Generated parser/parser.rs
Transpiling ir/ir_builder.mn -> ir/ir_builder.rs
âœ… Generated ir/ir_builder.rs
Transpiling ir/ir_nodes.mn -> ir/ir_nodes.rs
âœ… Generated ir/ir_nodes.rs
Transpiling lexer/lexer.mn -> lexer/lexer.rs
âœ… Generated lexer/lexer.rs
Transpiling lexer/token.mn -> lexer/token.rs
âœ… Generated lexer/token.rs
Transpiling builtins/codegen_helpers.mn -> builtins/codegen_helpers.rs
âœ… Generated builtins/codegen_helpers.rs
Transpiling codegen/rust_backend.mn -> codegen/rust_backend.rs
âœ… Generated codegen/rust_backend.rs
Transpiling semantic/analyzer.mn -> semantic/analyzer.rs
âœ… Generated semantic/analyzer.rs

Step 2: Creating Rust project structure...
âœ… Cargo.toml created

Step 3: Compiling Rust code...
   Compiling gul-compiler v0.1.0 (/media/vu/512gb/blob/gul/compiler_rust)
error: expected one of `,`, `=`, or `}`, found `;`
  --> ast/nodes.rs:51:25
   |
51 |     Grouped(GroupedExpr);
   |                         ^ expected one of `,`, `=`, or `}`
   |
   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`

error: expected one of `,`, `=`, or `}`, found `;`
  --> ast/nodes.rs:75:23
   |
75 |     PassStmt(PassStmt);
   |                       ^ expected one of `,`, `=`, or `}`
   |
   = help: enum variants can be `Variant`, `Variant = <integer>`, `Variant(Type, ..., TypeN)` or `Variant { fields: Types }`

error: expected identifier, found `,`
  --> ir/ir_builder.rs:24:13
   |
15 |         return IRBuilder {
   |                --------- while parsing this struct
...
24 |             ,
   |             ^ expected identifier
   |
help: remove this comma
   |
24 -             ,
   |

error: expected expression, found `;`
   --> lexer/token.rs:138:39
    |
138 |         let keywords = HashSet::from([;
    |                                       ^ expected expression

error: non-item in item list
   --> lexer/token.rs:149:6
    |
131 | impl Token {
    |            - item list starts here
...
149 |     };
    |      ^
    |      |
    |      non-item starts here
    |      help: consider removing this semicolon
...
174 | }
    | - item list ends here

error: `match` arm body without braces
   --> parser/parser.rs:280:17
    |
278 |             _ =>
    |               -- while parsing the `match` arm starting here
279 |                 // Try parsing as expression statement or assignment
280 |                 return self.parse_expression_or_assignment();
    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ this statement is not surrounded by a body
    |
help: replace `;` with `,` to end a `match` arm expression
    |
280 -                 return self.parse_expression_or_assignment();
280 +                 return self.parse_expression_or_assignment(),
    |

error: expected one of `.`, `?`, `]`, or an operator, found `:`
   --> parser/parser.rs:342:45
    |
342 |             return_type = type_token.value[1:]; // Remove @
    |                                             ^ expected one of `.`, `?`, `]`, or an operator
    |
help: maybe write a path separator here
    |
342 |             return_type = type_token.value[1::]; // Remove @
    |                                              +

error: expected expression, found `;`
   --> parser/parser.rs:396:59
    |
396 |             self.current().token_type == TokenType::Ref ||;
    |                                                           ^ expected expression

error: expected expression, found `;`
   --> parser/parser.rs:579:58
    |
579 |         self.current().token_type == TokenType::PlusEq ||;
    |                                                          ^ expected expression

error: expected identifier, found keyword `type`
  --> semantic/analyzer.rs:12:9
   |
10 | pub struct Symbol {
   |            ------ while parsing this struct
11 |     pub name: String,
12 |     pub type: String,
   |         ^^^^ expected identifier, found keyword
   |
help: escape `type` to use it as an identifier
   |
12 |     pub r#type: String,
   |         ++

error: expected `{`, found keyword `in`
  --> semantic/analyzer.rs:40:17
   |
40 |         if name in self.symbols {
   |                 ^^ expected `{`
   |
note: the `if` expression is missing a block after this condition
  --> semantic/analyzer.rs:40:12
   |
40 |         if name in self.symbols {
   |            ^^^^

error: expected one of `!`, `.`, `::`, `;`, `?`, `{`, `}`, or an operator, found keyword `in`
  --> semantic/analyzer.rs:53:21
   |
53 |         return name in self.symbols;
   |                     ^^ expected one of 8 possible tokens

error: expected identifier, found keyword `type`
   --> semantic/analyzer.rs:154:13
    |
154 |             type: stmt.type_annotation || value_type,
    |             ^^^^ expected identifier, found keyword
    |
help: escape `type` to use it as an identifier
    |
154 |             r#type: stmt.type_annotation || value_type,
    |             ++

error: expected identifier, found keyword `type`
   --> semantic/analyzer.rs:180:13
    |
180 |             type: stmt.type_annotation || value_type,
    |             ^^^^ expected identifier, found keyword
    |
help: escape `type` to use it as an identifier
    |
180 |             r#type: stmt.type_annotation || value_type,
    |             ++

error: expected identifier, found keyword `type`
   --> semantic/analyzer.rs:198:13
    |
198 |             type: stmt.return_type || "void",
    |             ^^^^ expected identifier, found keyword
    |
help: escape `type` to use it as an identifier
    |
198 |             r#type: stmt.return_type || "void",
    |             ++

error: expected identifier, found keyword `type`
   --> semantic/analyzer.rs:213:17
    |
213 |                 type: param.type_annotation || "any",
    |                 ^^^^ expected identifier, found keyword
    |
help: escape `type` to use it as an identifier
    |
213 |                 r#type: param.type_annotation || "any",
    |                 ++

error: expected identifier, found keyword `type`
   --> semantic/analyzer.rs:286:13
    |
286 |             type: "any", // TODO: infer from iterable type
    |             ^^^^ expected identifier, found keyword
    |
help: escape `type` to use it as an identifier
    |
286 |             r#type: "any", // TODO: infer from iterable type
    |             ++

error: expected expression, found `;`
   --> semantic/analyzer.rs:384:45
    |
384 |         expr.operator == TokenType::Minus ||;
    |                                             ^ expected expression

error: expected `,`, found `.`
  --> ast/nodes.rs:13:31
   |
13 |         return format!("{}:{}".to_string(), self.line, self.column);
   |                               ^ expected `,`

error: argument never used
  --> ast/nodes.rs:13:56
   |
13 |         return format!("{}:{}".to_string(), self.line, self.column);
   |                        -------                         ^^^^^^^^^^^ argument never used
   |                        |
   |                        formatting specifier missing

error: expected `,`, found `.`
  --> codegen/rust_backend.rs:40:40
   |
40 |         self.output.push(format!("{}{}".to_string(), indent_str, code));
   |                                        ^ expected `,`

error: argument never used
  --> codegen/rust_backend.rs:40:66
   |
40 |         self.output.push(format!("{}{}".to_string(), indent_str, code));
   |                                  ------                          ^^^^ argument never used
   |                                  |
   |                                  formatting specifier missing

error: expected `,`, found `.`
   --> codegen/rust_backend.rs:114:40
    |
114 |         let mut code = format!("let {}".to_string(), stmt.name);
    |                                        ^ expected `,`

error: argument never used
   --> codegen/rust_backend.rs:114:54
    |
114 |         let mut code = format!("let {}".to_string(), stmt.name);
    |                                --------              ^^^^^^^^^ argument never used
    |                                |
    |                                formatting specifier missing

error: expected `,`, found `.`
   --> codegen/rust_backend.rs:115:58
    |
115 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |                                                          ^ expected `,`

error: argument never used
   --> codegen/rust_backend.rs:115:78
    |
115 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |                                                  --------                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                                                  |
    |                                                  formatting specifier missing

error: expected `,`, found `.`
   --> codegen/rust_backend.rs:116:34
    |
116 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                                  ^ expected `,`

error: argument never used
   --> codegen/rust_backend.rs:116:54
    |
116 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                        ----------                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                        |
    |                        formatting specifier missing

error: expected `,`, found `.`
   --> codegen/rust_backend.rs:122:44
    |
122 |         let mut code = format!("let mut {}".to_string(), stmt.name);
    |                                            ^ expected `,`

error: argument never used
   --> codegen/rust_backend.rs:122:58
    |
122 |         let mut code = format!("let mut {}".to_string(), stmt.name);
    |                                ------------              ^^^^^^^^^ argument never used
    |                                |
    |                                formatting specifier missing

error: expected `,`, found `.`
   --> codegen/rust_backend.rs:123:58
    |
123 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |                                                          ^ expected `,`

error: argument never used
   --> codegen/rust_backend.rs:123:78
    |
123 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |                                                  --------                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                                                  |
    |                                                  formatting specifier missing

error: expected `,`, found `.`
   --> codegen/rust_backend.rs:124:34
    |
124 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                                  ^ expected `,`

error: argument never used
   --> codegen/rust_backend.rs:124:54
    |
124 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                        ----------                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                        |
    |                        formatting specifier missing

error: expected `,`, found `.`
   --> lexer/token.rs:133:88
    |
133 |         return format!("{self.token_type}('{self.value}') at {self.line}:{self.column}".to_string().to_string());
    |                                                                                        ^ expected `,`

error: invalid format string: field access isn't supported
   --> lexer/token.rs:133:26
    |
133 |         return format!("{self.token_type}('{self.value}') at {self.line}:{self.column}".to_string().to_string());
    |                          ^^^^^^^^^^^^^^^ not supported in format string
    |
help: consider using a positional formatting argument instead
    |
133 -         return format!("{self.token_type}('{self.value}') at {self.line}:{self.column}".to_string().to_string());
133 +         return format!("{1}('{self.value}') at {self.line}:{self.column}".to_string().to_string(), self.token_type);
    |

error: expected `,`, found `.`
   --> parser/parser.rs:106:22
    |
106 |         println!("{}".to_string(), "Parse error: ".to_string() + message);
    |                      ^ expected `,`

error: argument never used
   --> parser/parser.rs:106:36
    |
106 |         println!("{}".to_string(), "Parse error: ".to_string() + message);
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> parser/parser.rs:206:22
    |
206 |         println!("{}".to_string(), "    Parser: parse_program start".to_string());
    |                      ^ expected `,`

error: argument never used
   --> parser/parser.rs:206:36
    |
206 |         println!("{}".to_string(), "    Parser: parse_program start".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> parser/parser.rs:208:26
    |
208 |             println!("{}".to_string(), "    Parser POS: ".to_string() + &format!("{}".to_string(), self.current_pos));
    |                          ^ expected `,`

error: argument never used
   --> parser/parser.rs:208:40
    |
208 |             println!("{}".to_string(), "    Parser POS: ".to_string() + &format!("{}".to_string(), self.current_pos));
    |                      ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                      |
    |                      formatting specifier missing

error: expected `,`, found `.`
   --> parser/parser.rs:208:86
    |
208 |             println!("{}".to_string(), "    Parser POS: ".to_string() + &format!("{}".to_string(), self.current_pos));
    |                                                                                      ^ expected `,`

error: argument never used
   --> parser/parser.rs:208:100
    |
208 |             println!("{}".to_string(), "    Parser POS: ".to_string() + &format!("{}".to_string(), self.current_pos));
    |                                                                                  ----              ^^^^^^^^^^^^^^^^ argument never used
    |                                                                                  |
    |                                                                                  formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:102:73
    |
102 | ...   let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(),...
    |                                                                       ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:102:87
    |
102 | ...   let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(),...
    |                                                                   ----              ^^^^ argument never used
    |                                                                   |
    |                                                                   formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:102:127
    |
102 | ...!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                                                ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:102:141
    |
102 | ...tring(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                                 ----              ^^^^^^ argument never used
    |                                                 |
    |                                                 formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:104:22
    |
104 |         println!("{}".to_string(), error_msg);
    |                      ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:104:36
    |
104 |         println!("{}".to_string(), error_msg);
    |                  ----              ^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:109:65
    |
109 | ...   let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column)...
    |                                                               ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:109:79
    |
109 | ...   let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column)...
    |                                                           ----              ^^^^ argument never used
    |                                                           |
    |                                                           formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:109:119
    |
109 | ...   let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column)...
    |                                                                                                                     ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:109:133
    |
109 | ...tring(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                                 ----              ^^^^^^ argument never used
    |                                                 |
    |                                                 formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:137:63
    |
137 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                               ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:137:77
    |
137 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                -------------------------------              ^^^^^^^^^ argument never used
    |                                |
    |                                formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:146:72
    |
146 |                 self.error(format!("Type mismatch: expected {}, got {}".to_string(), stmt.type_annotation, value_type),
    |                                                                        ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:146:108
    |
146 |                 self.error(format!("Type mismatch: expected {}, got {}".to_string(), stmt.type_annotation, value_type),
    |                                    ------------------------------------ formatting specifier missing       ^^^^^^^^^^ argument never used

error: expected `,`, found `.`
   --> semantic/analyzer.rs:166:63
    |
166 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                               ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:166:77
    |
166 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                -------------------------------              ^^^^^^^^^ argument never used
    |                                |
    |                                formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:173:72
    |
173 |                 self.error(format!("Type mismatch: expected {}, got {}".to_string(), stmt.type_annotation, value_type),
    |                                                                        ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:173:108
    |
173 |                 self.error(format!("Type mismatch: expected {}, got {}".to_string(), stmt.type_annotation, value_type),
    |                                    ------------------------------------ formatting specifier missing       ^^^^^^^^^^ argument never used

error: expected `,`, found `.`
   --> semantic/analyzer.rs:192:63
    |
192 |             self.error(format!("Function '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                               ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:192:77
    |
192 |             self.error(format!("Function '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                -------------------------------              ^^^^^^^^^ argument never used
    |                                |
    |                                formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:236:65
    |
236 |             self.warn(format!("Condition should be bool, got {}".to_string(), cond_type), stmt.base.node.line, stmt.base.node.column);
    |                                                                 ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:236:79
    |
236 |             self.warn(format!("Condition should be bool, got {}".to_string(), cond_type), stmt.base.node.line, stmt.base.node.column);
    |                               ----------------------------------              ^^^^^^^^^ argument never used
    |                               |
    |                               formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:316:61
    |
316 |                 self.error(format!("Undefined variable '{}'".to_string(), ident.name), stmt.base.node.line, stmt.base.node.column);
    |                                                             ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:316:75
    |
316 |                 self.error(format!("Undefined variable '{}'".to_string(), ident.name), stmt.base.node.line, stmt.base.node.column);
    |                                    -------------------------              ^^^^^^^^^^ argument never used
    |                                    |
    |                                    formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:319:78
    |
319 |                 self.error(format!("Cannot assign to immutable variable '{}'".to_string(), ident.name),
    |                                                                              ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:319:92
    |
319 |                 self.error(format!("Cannot assign to immutable variable '{}'".to_string(), ident.name),
    |                                    ------------------------------------------              ^^^^^^^^^^ argument never used
    |                                    |
    |                                    formatting specifier missing

error: expected `,`, found `.`
   --> semantic/analyzer.rs:370:57
    |
370 |             self.error(format!("Undefined variable '{}'".to_string(), expr.name), expr.base.node.line, expr.base.node.column);
    |                                                         ^ expected `,`

error: argument never used
   --> semantic/analyzer.rs:370:71
    |
370 |             self.error(format!("Undefined variable '{}'".to_string(), expr.name), expr.base.node.line, expr.base.node.column);
    |                                -------------------------              ^^^^^^^^^ argument never used
    |                                |
    |                                formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:107:22
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                      ^ expected `,`

error: argument never used
   --> main.rs:107:36
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:107:86
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                      ^ expected `,`

error: argument never used
   --> main.rs:107:100
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                  ----              ^ argument never used
    |                                                                                  |
    |                                                                                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:117:26
    |
117 |             println!("{}".to_string(), "Generated code written to ".to_string() + compiler.config.output_file);
    |                          ^ expected `,`

error: argument never used
   --> main.rs:117:40
    |
117 |             println!("{}".to_string(), "Generated code written to ".to_string() + compiler.config.output_file);
    |                      ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                      |
    |                      formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:121:22
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                      ^ expected `,`

error: argument never used
   --> main.rs:121:36
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:121:86
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                      ^ expected `,`

error: argument never used
   --> main.rs:121:100
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                  ----              ^ argument never used
    |                                                                                  |
    |                                                                                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:141:18
    |
141 |     println!("{}".to_string(), "  [1/4] Lexing...".to_string());
    |                  ^ expected `,`

error: argument never used
   --> main.rs:141:32
    |
141 |     println!("{}".to_string(), "  [1/4] Lexing...".to_string());
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:143:18
    |
143 |     println!("{}".to_string(), "    Lexed ".to_string() + &format!("{}".to_string(), (tokens).len()) + " tokens");
    |                  ^ expected `,`

error: argument never used
   --> main.rs:143:32
    |
143 |     println!("{}".to_string(), "    Lexed ".to_string() + &format!("{}".to_string(), (tokens).len()) + " tokens");
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:143:72
    |
143 |     println!("{}".to_string(), "    Lexed ".to_string() + &format!("{}".to_string(), (tokens).len()) + " tokens");
    |                                                                        ^ expected `,`

error: argument never used
   --> main.rs:143:86
    |
143 |     println!("{}".to_string(), "    Lexed ".to_string() + &format!("{}".to_string(), (tokens).len()) + " tokens");
    |                                                                    ----              ^^^^^^^^^^^^^^ argument never used
    |                                                                    |
    |                                                                    formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:145:18
    |
145 |     println!("{}".to_string(), "  [2/4] Parsing...".to_string());
    |                  ^ expected `,`

error: argument never used
   --> main.rs:145:32
    |
145 |     println!("{}".to_string(), "  [2/4] Parsing...".to_string());
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:153:26
    |
153 |             println!("{}".to_string(), "  [3/4] Semantic analysis...".to_string());
    |                          ^ expected `,`

error: argument never used
   --> main.rs:153:40
    |
153 |             println!("{}".to_string(), "  [3/4] Semantic analysis...".to_string());
    |                      ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                      |
    |                      formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:164:18
    |
164 |     println!("{}".to_string(), "  [3/4] Semantic analysis...".to_string());
    |                  ^ expected `,`

error: argument never used
   --> main.rs:164:32
    |
164 |     println!("{}".to_string(), "  [3/4] Semantic analysis...".to_string());
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:167:18
    |
167 |     println!("{}".to_string(), "  [4/4] Generating Rust code...".to_string());
    |                  ^ expected `,`

error: argument never used
   --> main.rs:167:32
    |
167 |     println!("{}".to_string(), "  [4/4] Generating Rust code...".to_string());
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:171:22
    |
171 |         println!("{}".to_string(), "Debug: Generated Rust code length: ".to_string() + (rust_code).len());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:171:36
    |
171 |         println!("{}".to_string(), "Debug: Generated Rust code length: ".to_string() + (rust_code).len());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:173:18
    |
173 |     println!("{}".to_string(), "FORCE DEBUG: Rust code length: ".to_string() + (rust_code).len());
    |                  ^ expected `,`

error: argument never used
   --> main.rs:173:32
    |
173 |     println!("{}".to_string(), "FORCE DEBUG: Rust code length: ".to_string() + (rust_code).len());
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:175:22
    |
175 |         println!("{}".to_string(), "Debug: Rust code preview:".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:175:36
    |
175 |         println!("{}".to_string(), "Debug: Rust code preview:".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:176:22
    |
176 |         println!("{}".to_string(), rust_code);
    |                      ^ expected `,`

error: argument never used
   --> main.rs:176:36
    |
176 |         println!("{}".to_string(), rust_code);
    |                  ----              ^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:185:22
    |
185 |         println!("{}".to_string(), "Compilation successful!".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:185:36
    |
185 |         println!("{}".to_string(), "Compilation successful!".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:193:18
    |
193 |     println!("{}".to_string(), "ENTER compile_file".to_string());
    |                  ^ expected `,`

error: argument never used
   --> main.rs:193:32
    |
193 |     println!("{}".to_string(), "ENTER compile_file".to_string());
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:199:18
    |
199 |     println!("{}".to_string(), "DEBUG: Result success: ".to_string() + &format!("{}".to_string(), result.success));
    |                  ^ expected `,`

error: argument never used
   --> main.rs:199:32
    |
199 |     println!("{}".to_string(), "DEBUG: Result success: ".to_string() + &format!("{}".to_string(), result.success));
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:199:85
    |
199 |     println!("{}".to_string(), "DEBUG: Result success: ".to_string() + &format!("{}".to_string(), result.success));
    |                                                                                     ^ expected `,`

error: argument never used
   --> main.rs:199:99
    |
199 |     println!("{}".to_string(), "DEBUG: Result success: ".to_string() + &format!("{}".to_string(), result.success));
    |                                                                                 ----              ^^^^^^^^^^^^^^ argument never used
    |                                                                                 |
    |                                                                                 formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:200:18
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |                  ^ expected `,`

error: argument never used
   --> main.rs:200:32
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |              ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |              |
    |              formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:200:84
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |                                                                                    ^ expected `,`

error: argument never used
   --> main.rs:200:98
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |                                                                                ----              ^^^^^^^^^^^^^ argument never used
    |                                                                                |
    |                                                                                formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:217:22
    |
217 |         println!("{}".to_string(), "GUL Compiler v0.1.0".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:217:36
    |
217 |         println!("{}".to_string(), "GUL Compiler v0.1.0".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:218:22
    |
218 |         println!("{}".to_string(), "Usage: gul-compile <input.mn> [options]".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:218:36
    |
218 |         println!("{}".to_string(), "Usage: gul-compile <input.mn> [options]".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:219:22
    |
219 |         println!("{}".to_string(), "Options:".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:219:36
    |
219 |         println!("{}".to_string(), "Options:".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:220:22
    |
220 |         println!("{}".to_string(), "  -o <file>      Output file (default: input.rs)".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:220:36
    |
220 |         println!("{}".to_string(), "  -o <file>      Output file (default: input.rs)".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:221:22
    |
221 |         println!("{}".to_string(), "  --verbose      Verbose output".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:221:36
    |
221 |         println!("{}".to_string(), "  --verbose      Verbose output".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:222:22
    |
222 |         println!("{}".to_string(), "  --no-semantic  Skip semantic analysis".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:222:36
    |
222 |         println!("{}".to_string(), "  --no-semantic  Skip semantic analysis".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:260:22
    |
260 |         println!("{}".to_string(), "Compilation successful!".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:260:36
    |
260 |         println!("{}".to_string(), "Compilation successful!".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:262:26
    |
262 |             println!("{}".to_string(), "Warnings: ".to_string() + &format!("{}".to_string(), (result.warnings).len()));
    |                          ^ expected `,`

error: argument never used
   --> main.rs:262:40
    |
262 |             println!("{}".to_string(), "Warnings: ".to_string() + &format!("{}".to_string(), (result.warnings).len()));
    |                      ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                      |
    |                      formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:262:80
    |
262 |             println!("{}".to_string(), "Warnings: ".to_string() + &format!("{}".to_string(), (result.warnings).len()));
    |                                                                                ^ expected `,`

error: argument never used
   --> main.rs:262:94
    |
262 |             println!("{}".to_string(), "Warnings: ".to_string() + &format!("{}".to_string(), (result.warnings).len()));
    |                                                                            ----              ^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                                                                            |
    |                                                                            formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:266:22
    |
266 |         println!("{}".to_string(), "Compilation failed!".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:266:36
    |
266 |         println!("{}".to_string(), "Compilation failed!".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:268:22
    |
268 |         println!("{}".to_string(), "DEBUG: Result fields available? (Check interpreter debug)".to_string());
    |                      ^ expected `,`

error: argument never used
   --> main.rs:268:36
    |
268 |         println!("{}".to_string(), "DEBUG: Result fields available? (Check interpreter debug)".to_string());
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:271:22
    |
271 |         println!("{}".to_string(), "DEBUG: errors var type: ".to_string() + &format!("{}".to_string(), "unknown".to_string()));
    |                      ^ expected `,`

error: argument never used
   --> main.rs:271:36
    |
271 |         println!("{}".to_string(), "DEBUG: errors var type: ".to_string() + &format!("{}".to_string(), "unknown".to_string()));
    |                  ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                  |
    |                  formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:271:90
    |
271 |         println!("{}".to_string(), "DEBUG: errors var type: ".to_string() + &format!("{}".to_string(), "unknown".to_string()));
    |                                                                                          ^ expected `,`

error: argument never used
   --> main.rs:271:104
    |
271 |         println!("{}".to_string(), "DEBUG: errors var type: ".to_string() + &format!("{}".to_string(), "unknown".to_string()));
    |                                                                                      ----              ^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                                                                                      |
    |                                                                                      formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:273:26
    |
273 |             println!("{}".to_string(), "Errors list length: ".to_string() + (errs).len());
    |                          ^ expected `,`

error: argument never used
   --> main.rs:273:40
    |
273 |             println!("{}".to_string(), "Errors list length: ".to_string() + (errs).len());
    |                      ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                      |
    |                      formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:275:30
    |
275 |                 println!("{}".to_string(), "  ".to_string() + error);
    |                              ^ expected `,`

error: argument never used
   --> main.rs:275:44
    |
275 |                 println!("{}".to_string(), "  ".to_string() + error);
    |                          ----              ^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                          |
    |                          formatting specifier missing

error: expected `,`, found `.`
   --> main.rs:279:26
    |
279 |             println!("{}".to_string(), "Result.errors is None || empty".to_string());
    |                          ^ expected `,`

error: argument never used
   --> main.rs:279:40
    |
279 |             println!("{}".to_string(), "Result.errors is None || empty".to_string());
    |                      ----              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ argument never used
    |                      |
    |                      formatting specifier missing

error[E0412]: cannot find type `HashMap` in this scope
   --> ast/nodes.rs:139:23
    |
139 |     pub keyword_args: HashMap<String, String>,
    |                       ^^^^^^^ not found in this scope
    |
help: consider importing one of these structs
    |
  2 + use crate::HashMap;
    |
  2 + use std::collections::HashMap;
    |

error[E0425]: cannot find value `items` in this scope
   --> codegen/rust_backend.rs:254:47
    |
254 |             let items = ", ".to_string().join(items);
    |                                               ^^^^^ not found in this scope

error[E0423]: expected value, found struct `CodeGenerator`
   --> codegen/rust_backend.rs:449:25
    |
449 |     let mut generator = CodeGenerator.create();
    |                         ^^^^^^^^^^^^^
    |
help: use the path separator to refer to an item
    |
449 -     let mut generator = CodeGenerator.create();
449 +     let mut generator = CodeGenerator::create();
    |

error[E0412]: cannot find type `HashMap` in this scope
  --> ir/ir_builder.rs:10:24
   |
10 |     pub pending_impls: HashMap<String, Vec<IRFunction>>,
   |                        ^^^^^^^ not found in this scope
   |
help: consider importing one of these structs
   |
 1 + use crate::HashMap;
   |
 1 + use std::collections::HashMap;
   |

error[E0433]: failed to resolve: use of undeclared type `HashMap`
  --> ir/ir_builder.rs:26:28
   |
26 |             pending_impls: HashMap::new(),
   |                            ^^^^^^^ use of undeclared type `HashMap`
   |
help: consider importing one of these structs
   |
 1 + use crate::HashMap;
   |
 1 + use std::collections::HashMap;
   |

error[E0412]: cannot find type `Module` in this scope
  --> ir/ir_builder.rs:30:41
   |
30 |     pub fn build_module(&mut self, ast: Module)  ->  IRModule {
   |                                         ^^^^^^
   |
  ::: ir/ir_nodes.rs:34:1
   |
34 | pub struct IRModule {
   | ------------------- similarly named struct `IRModule` defined here
   |
help: there is an enum variant `crate::ir::ir_nodes::IRNodeType::Module`; try using the variant's enum
   |
30 -     pub fn build_module(&mut self, ast: Module)  ->  IRModule {
30 +     pub fn build_module(&mut self, ast: crate::ir::ir_nodes::IRNodeType)  ->  IRModule {
   |
help: a struct with a similar name exists
   |
30 |     pub fn build_module(&mut self, ast: IRModule)  ->  IRModule {
   |                                         ++

error[E0425]: cannot find value `token` in this scope
  --> lexer/lexer.rs:94:16
   |
94 |             if token.is_keyword(ident) {
   |                ^^^^^ not found in this scope

error[E0425]: cannot find value `token` in this scope
  --> lexer/lexer.rs:95:21
   |
95 |                 t = token.get_keyword_type(ident);
   |                     ^^^^^ not found in this scope

error[E0425]: cannot find value `clause` in this scope
   --> parser/parser.rs:460:27
    |
460 |         elif_clauses.push(clause);
    |                           ^^^^^^
    |
help: the binding `clause` is available in a different scope in the same function
   --> parser/parser.rs:454:17
    |
454 |             let clause = ElifClause{
    |                 ^^^^^^

error[E0412]: cannot find type `HashMap` in this scope
  --> semantic/analyzer.rs:21:18
   |
21 |     pub symbols: HashMap<String, String>, // name -> Symbol
   |                  ^^^^^^^ not found in this scope
   |
help: consider importing one of these structs
   |
 4 + use crate::HashMap;
   |
 4 + use std::collections::HashMap;
   |

error[E0433]: failed to resolve: use of undeclared type `HashMap`
  --> semantic/analyzer.rs:26:27
   |
26 |     return Scope{symbols: HashMap::new(), parent: None};
   |                           ^^^^^^^ use of undeclared type `HashMap`
   |
help: consider importing one of these structs
   |
 4 + use crate::HashMap;
   |
 4 + use std::collections::HashMap;
   |

error[E0433]: failed to resolve: use of undeclared type `HashMap`
  --> semantic/analyzer.rs:30:27
   |
30 |     return Scope{symbols: HashMap::new(), parent: parent};
   |                           ^^^^^^^ use of undeclared type `HashMap`
   |
help: consider importing one of these structs
   |
 4 + use crate::HashMap;
   |
 4 + use std::collections::HashMap;
   |

error[E0412]: cannot find type `ListLiteralExpr` in this scope
   --> semantic/analyzer.rs:357:89
    |
357 |         else if et == ExprType::ListLiteral { return self.analyze_list_literal((expr as ListLiteralExpr)) }
    |                                                                                         ^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `LiteralExpr`
    |
   ::: ast/nodes.rs:107:1
    |
107 | pub struct LiteralExpr {
    | ---------------------- similarly named struct `LiteralExpr` defined here

error[E0412]: cannot find type `TupleLiteralExpr` in this scope
   --> semantic/analyzer.rs:358:91
    |
358 |         else if et == ExprType::TupleLiteral { return self.analyze_tuple_literal((expr as TupleLiteralExpr)) }
    |                                                                                           ^^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `LiteralExpr`
    |
   ::: ast/nodes.rs:107:1
    |
107 | pub struct LiteralExpr {
    | ---------------------- similarly named struct `LiteralExpr` defined here

error[E0412]: cannot find type `SetLiteralExpr` in this scope
   --> semantic/analyzer.rs:359:87
    |
359 |         else if et == ExprType::SetLiteral { return self.analyze_set_literal((expr as SetLiteralExpr)) }
    |                                                                                       ^^^^^^^^^^^^^^ help: a struct with a similar name exists: `LiteralExpr`
    |
   ::: ast/nodes.rs:107:1
    |
107 | pub struct LiteralExpr {
    | ---------------------- similarly named struct `LiteralExpr` defined here

error[E0412]: cannot find type `DictLiteralExpr` in this scope
   --> semantic/analyzer.rs:360:89
    |
360 |         else if et == ExprType::DictLiteral { return self.analyze_dict_literal((expr as DictLiteralExpr)) }
    |                                                                                         ^^^^^^^^^^^^^^^ help: a struct with a similar name exists: `LiteralExpr`
    |
   ::: ast/nodes.rs:107:1
    |
107 | pub struct LiteralExpr {
    | ---------------------- similarly named struct `LiteralExpr` defined here

error[E0425]: cannot find value `e` in this scope
   --> main.rs:107:100
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                                    ^ not found in this scope

error[E0425]: cannot find value `e` in this scope
   --> main.rs:121:100
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                                    ^ not found in this scope

warning: unnecessary trailing semicolon
   --> lexer/token.rs:182:5
    |
182 |     ;
    |     ^ help: remove this semicolon
    |
    = note: `#[warn(redundant_semicolons)]` (part of `#[warn(unused)]`) on by default

warning: denote infinite loops with `loop { ... }`
   --> parser/parser.rs:112:9
    |
112 |         while true {
    |         ^^^^^^^^^^ help: use `loop`
    |
    = note: `#[warn(while_true)]` on by default

warning: unnecessary trailing semicolon
   --> parser/parser.rs:306:9
    |
306 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:331:9
    |
331 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:383:9
    |
383 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:412:9
    |
412 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:478:9
    |
478 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:458:13
    |
458 |             ;
    |             ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:495:9
    |
495 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:515:9
    |
515 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:532:9
    |
532 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary trailing semicolon
   --> parser/parser.rs:569:9
    |
569 |         ;
    |         ^ help: remove this semicolon

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:120:60
    |
120 |         if st == StmtType::LetDecl { self.analyze_let_stmt((stmt as LetStmt)) }
    |                                                            ^               ^
    |
    = note: `#[warn(unused_parens)]` (part of `#[warn(unused)]`) on by default
help: remove these parentheses
    |
120 -         if st == StmtType::LetDecl { self.analyze_let_stmt((stmt as LetStmt)) }
120 +         if st == StmtType::LetDecl { self.analyze_let_stmt(stmt as LetStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:121:65
    |
121 |         else if st == StmtType::VarDecl { self.analyze_var_stmt((stmt as VarStmt)) }
    |                                                                 ^               ^
    |
help: remove these parentheses
    |
121 -         else if st == StmtType::VarDecl { self.analyze_var_stmt((stmt as VarStmt)) }
121 +         else if st == StmtType::VarDecl { self.analyze_var_stmt(stmt as VarStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:122:75
    |
122 |         else if st == StmtType::FunctionDecl { self.analyze_function_decl((stmt as FunctionDecl)) }
    |                                                                           ^                    ^
    |
help: remove these parentheses
    |
122 -         else if st == StmtType::FunctionDecl { self.analyze_function_decl((stmt as FunctionDecl)) }
122 +         else if st == StmtType::FunctionDecl { self.analyze_function_decl(stmt as FunctionDecl) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:123:63
    |
123 |         else if st == StmtType::IfStmt { self.analyze_if_stmt((stmt as IfStmt)) }
    |                                                               ^              ^
    |
help: remove these parentheses
    |
123 -         else if st == StmtType::IfStmt { self.analyze_if_stmt((stmt as IfStmt)) }
123 +         else if st == StmtType::IfStmt { self.analyze_if_stmt(stmt as IfStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:124:69
    |
124 |         else if st == StmtType::WhileStmt { self.analyze_while_stmt((stmt as WhileStmt)) }
    |                                                                     ^                 ^
    |
help: remove these parentheses
    |
124 -         else if st == StmtType::WhileStmt { self.analyze_while_stmt((stmt as WhileStmt)) }
124 +         else if st == StmtType::WhileStmt { self.analyze_while_stmt(stmt as WhileStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:125:65
    |
125 |         else if st == StmtType::ForStmt { self.analyze_for_stmt((stmt as ForStmt)) }
    |                                                                 ^               ^
    |
help: remove these parentheses
    |
125 -         else if st == StmtType::ForStmt { self.analyze_for_stmt((stmt as ForStmt)) }
125 +         else if st == StmtType::ForStmt { self.analyze_for_stmt(stmt as ForStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:126:71
    |
126 |         else if st == StmtType::ReturnStmt { self.analyze_return_stmt((stmt as ReturnStmt)) }
    |                                                                       ^                  ^
    |
help: remove these parentheses
    |
126 -         else if st == StmtType::ReturnStmt { self.analyze_return_stmt((stmt as ReturnStmt)) }
126 +         else if st == StmtType::ReturnStmt { self.analyze_return_stmt(stmt as ReturnStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:127:74
    |
127 |         else if st == StmtType::AssignmentStmt { self.analyze_assignment((stmt as AssignmentStmt)) }
    |                                                                          ^                      ^
    |
help: remove these parentheses
    |
127 -         else if st == StmtType::AssignmentStmt { self.analyze_assignment((stmt as AssignmentStmt)) }
127 +         else if st == StmtType::AssignmentStmt { self.analyze_assignment(stmt as AssignmentStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:128:79
    |
128 |         else if st == StmtType::ExpressionStmt { self.analyze_expression_stmt((stmt as ExpressionStmt)) }
    |                                                                               ^                      ^
    |
help: remove these parentheses
    |
128 -         else if st == StmtType::ExpressionStmt { self.analyze_expression_stmt((stmt as ExpressionStmt)) }
128 +         else if st == StmtType::ExpressionStmt { self.analyze_expression_stmt(stmt as ExpressionStmt) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:129:66
    |
129 |         else if st == StmtType::ImportStmt { self.analyze_import((stmt as ImportStmt)) }
    |                                                                  ^                  ^
    |
help: remove these parentheses
    |
129 -         else if st == StmtType::ImportStmt { self.analyze_import((stmt as ImportStmt)) }
129 +         else if st == StmtType::ImportStmt { self.analyze_import(stmt as ImportStmt) }
    |

warning: unnecessary parentheses around assigned value
   --> semantic/analyzer.rs:312:25
    |
312 |             let ident = (stmt.target as IdentifierExpr);
    |                         ^                             ^
    |
help: remove these parentheses
    |
312 -             let ident = (stmt.target as IdentifierExpr);
312 +             let ident = stmt.target as IdentifierExpr;
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:351:77
    |
351 |         else if et == ExprType::Identifier { return self.analyze_identifier((expr as IdentifierExpr)) }
    |                                                                             ^                      ^
    |
help: remove these parentheses
    |
351 -         else if et == ExprType::Identifier { return self.analyze_identifier((expr as IdentifierExpr)) }
351 +         else if et == ExprType::Identifier { return self.analyze_identifier(expr as IdentifierExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:352:74
    |
352 |         else if et == ExprType::BinaryOp { return self.analyze_binary_op((expr as BinaryOpExpr)) }
    |                                                                          ^                    ^
    |
help: remove these parentheses
    |
352 -         else if et == ExprType::BinaryOp { return self.analyze_binary_op((expr as BinaryOpExpr)) }
352 +         else if et == ExprType::BinaryOp { return self.analyze_binary_op(expr as BinaryOpExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:353:72
    |
353 |         else if et == ExprType::UnaryOp { return self.analyze_unary_op((expr as UnaryOpExpr)) }
    |                                                                        ^                   ^
    |
help: remove these parentheses
    |
353 -         else if et == ExprType::UnaryOp { return self.analyze_unary_op((expr as UnaryOpExpr)) }
353 +         else if et == ExprType::UnaryOp { return self.analyze_unary_op(expr as UnaryOpExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:354:65
    |
354 |         else if et == ExprType::Call { return self.analyze_call((expr as CallExpr)) }
    |                                                                 ^                ^
    |
help: remove these parentheses
    |
354 -         else if et == ExprType::Call { return self.analyze_call((expr as CallExpr)) }
354 +         else if et == ExprType::Call { return self.analyze_call(expr as CallExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:355:67
    |
355 |         else if et == ExprType::Index { return self.analyze_index((expr as IndexExpr)) }
    |                                                                   ^                 ^
    |
help: remove these parentheses
    |
355 -         else if et == ExprType::Index { return self.analyze_index((expr as IndexExpr)) }
355 +         else if et == ExprType::Index { return self.analyze_index(expr as IndexExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:356:75
    |
356 |         else if et == ExprType::Attribute { return self.analyze_attribute((expr as AttributeExpr)) }
    |                                                                           ^                     ^
    |
help: remove these parentheses
    |
356 -         else if et == ExprType::Attribute { return self.analyze_attribute((expr as AttributeExpr)) }
356 +         else if et == ExprType::Attribute { return self.analyze_attribute(expr as AttributeExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:357:80
    |
357 |         else if et == ExprType::ListLiteral { return self.analyze_list_literal((expr as ListLiteralExpr)) }
    |                                                                                ^                       ^
    |
help: remove these parentheses
    |
357 -         else if et == ExprType::ListLiteral { return self.analyze_list_literal((expr as ListLiteralExpr)) }
357 +         else if et == ExprType::ListLiteral { return self.analyze_list_literal(expr as ListLiteralExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:358:82
    |
358 |         else if et == ExprType::TupleLiteral { return self.analyze_tuple_literal((expr as TupleLiteralExpr)) }
    |                                                                                  ^                        ^
    |
help: remove these parentheses
    |
358 -         else if et == ExprType::TupleLiteral { return self.analyze_tuple_literal((expr as TupleLiteralExpr)) }
358 +         else if et == ExprType::TupleLiteral { return self.analyze_tuple_literal(expr as TupleLiteralExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:359:78
    |
359 |         else if et == ExprType::SetLiteral { return self.analyze_set_literal((expr as SetLiteralExpr)) }
    |                                                                              ^                      ^
    |
help: remove these parentheses
    |
359 -         else if et == ExprType::SetLiteral { return self.analyze_set_literal((expr as SetLiteralExpr)) }
359 +         else if et == ExprType::SetLiteral { return self.analyze_set_literal(expr as SetLiteralExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:360:80
    |
360 |         else if et == ExprType::DictLiteral { return self.analyze_dict_literal((expr as DictLiteralExpr)) }
    |                                                                                ^                       ^
    |
help: remove these parentheses
    |
360 -         else if et == ExprType::DictLiteral { return self.analyze_dict_literal((expr as DictLiteralExpr)) }
360 +         else if et == ExprType::DictLiteral { return self.analyze_dict_literal(expr as DictLiteralExpr) }
    |

warning: unnecessary parentheses around method argument
   --> semantic/analyzer.rs:361:88
    |
361 |         else if et == ExprType::TypeConstructor { return self.analyze_type_constructor((expr as TypeConstructorExpr)) }
    |                                                                                        ^                           ^
    |
help: remove these parentheses
    |
361 -         else if et == ExprType::TypeConstructor { return self.analyze_type_constructor((expr as TypeConstructorExpr)) }
361 +         else if et == ExprType::TypeConstructor { return self.analyze_type_constructor(expr as TypeConstructorExpr) }
    |

error[E0072]: recursive type `analyzer::Scope` has infinite size
  --> semantic/analyzer.rs:20:1
   |
20 | pub struct Scope {
   | ^^^^^^^^^^^^^^^^
21 |     pub symbols: HashMap<String, String>, // name -> Symbol
22 |     pub parent: Scope, // Can be None
   |                 ----- recursive without indirection
   |
help: insert some indirection (e.g., a `Box`, `Rc`, or `&`) to break the cycle
   |
22 |     pub parent: Box<Scope>, // Can be None
   |                 ++++     +

error: reached the recursion limit finding the struct tail for `analyzer::Scope`
  |
  = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]`

error[E0592]: duplicate definitions with name `parse_statement`
   --> parser/parser.rs:163:5
    |
163 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ duplicate definitions for `parse_statement`
...
239 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ------------------------------------------------ other definition for `parse_statement`

error[E0425]: cannot find function `to_string` in this scope
  --> ast/nodes.rs:13:32
   |
13 |         return format!("{}:{}".to_string(), self.line, self.column);
   |                                ^^^^^^^^^ not found in this scope

error[E0369]: binary operation `==` cannot be applied to type `&nodes::LiteralExpr`
   --> ast/nodes.rs:37:13
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
 36 | pub enum Expression {
 37 |     Literal(LiteralExpr),
    |             ^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::LiteralExpr`
   --> ast/nodes.rs:107:1
    |
107 | pub struct LiteralExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::LiteralExpr` with `#[derive(PartialEq)]`
    |
107 + #[derive(PartialEq)]
108 | pub struct LiteralExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::IdentifierExpr`
   --> ast/nodes.rs:38:16
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 38 |     Identifier(IdentifierExpr),
    |                ^^^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::IdentifierExpr`
   --> ast/nodes.rs:114:1
    |
114 | pub struct IdentifierExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::IdentifierExpr` with `#[derive(PartialEq)]`
    |
114 + #[derive(PartialEq)]
115 | pub struct IdentifierExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::BinaryOpExpr`
   --> ast/nodes.rs:39:14
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 39 |     BinaryOp(BinaryOpExpr),
    |              ^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::BinaryOpExpr`
   --> ast/nodes.rs:120:1
    |
120 | pub struct BinaryOpExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::BinaryOpExpr` with `#[derive(PartialEq)]`
    |
120 + #[derive(PartialEq)]
121 | pub struct BinaryOpExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::UnaryOpExpr`
   --> ast/nodes.rs:40:13
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 40 |     UnaryOp(UnaryOpExpr),
    |             ^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::UnaryOpExpr`
   --> ast/nodes.rs:128:1
    |
128 | pub struct UnaryOpExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::UnaryOpExpr` with `#[derive(PartialEq)]`
    |
128 + #[derive(PartialEq)]
129 | pub struct UnaryOpExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::CallExpr`
   --> ast/nodes.rs:41:10
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 41 |     Call(CallExpr),
    |          ^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::CallExpr`
   --> ast/nodes.rs:135:1
    |
135 | pub struct CallExpr {
    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::CallExpr` with `#[derive(PartialEq)]`
    |
135 + #[derive(PartialEq)]
136 | pub struct CallExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::IndexExpr`
   --> ast/nodes.rs:42:11
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 42 |     Index(IndexExpr),
    |           ^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::IndexExpr`
   --> ast/nodes.rs:143:1
    |
143 | pub struct IndexExpr {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::IndexExpr` with `#[derive(PartialEq)]`
    |
143 + #[derive(PartialEq)]
144 | pub struct IndexExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::AttributeExpr`
   --> ast/nodes.rs:43:15
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 43 |     Attribute(AttributeExpr),
    |               ^^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::AttributeExpr`
   --> ast/nodes.rs:150:1
    |
150 | pub struct AttributeExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::AttributeExpr` with `#[derive(PartialEq)]`
    |
150 + #[derive(PartialEq)]
151 | pub struct AttributeExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::ListExpr`
   --> ast/nodes.rs:44:10
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 44 |     List(ListExpr),
    |          ^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::ListExpr`
   --> ast/nodes.rs:157:1
    |
157 | pub struct ListExpr {
    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::ListExpr` with `#[derive(PartialEq)]`
    |
157 + #[derive(PartialEq)]
158 | pub struct ListExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::TupleExpr`
   --> ast/nodes.rs:45:11
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 45 |     Tuple(TupleExpr),
    |           ^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::TupleExpr`
   --> ast/nodes.rs:163:1
    |
163 | pub struct TupleExpr {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::TupleExpr` with `#[derive(PartialEq)]`
    |
163 + #[derive(PartialEq)]
164 | pub struct TupleExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::SetExpr`
   --> ast/nodes.rs:46:9
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 46 |     Set(SetExpr),
    |         ^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::SetExpr`
   --> ast/nodes.rs:169:1
    |
169 | pub struct SetExpr {
    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::SetExpr` with `#[derive(PartialEq)]`
    |
169 + #[derive(PartialEq)]
170 | pub struct SetExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::DictExpr`
   --> ast/nodes.rs:47:10
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 47 |     Dict(DictExpr),
    |          ^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::DictExpr`
   --> ast/nodes.rs:175:1
    |
175 | pub struct DictExpr {
    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::DictExpr` with `#[derive(PartialEq)]`
    |
175 + #[derive(PartialEq)]
176 | pub struct DictExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&LambdaExpr`
   --> ast/nodes.rs:48:12
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 48 |     Lambda(LambdaExpr),
    |            ^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `LambdaExpr`
   --> ast/nodes.rs:181:1
    |
181 | pub struct LambdaExpr {
    | ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `LambdaExpr` with `#[derive(PartialEq)]`
    |
181 + #[derive(PartialEq)]
182 | pub struct LambdaExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&MatchExpr`
   --> ast/nodes.rs:49:11
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 49 |     Match(MatchExpr),
    |           ^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `MatchExpr`
   --> ast/nodes.rs:188:1
    |
188 | pub struct MatchExpr {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `MatchExpr` with `#[derive(PartialEq)]`
    |
188 + #[derive(PartialEq)]
189 | pub struct MatchExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::TypeConstructorExpr`
   --> ast/nodes.rs:50:21
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 50 |     TypeConstructor(TypeConstructorExpr),
    |                     ^^^^^^^^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::TypeConstructorExpr`
   --> ast/nodes.rs:202:1
    |
202 | pub struct TypeConstructorExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::TypeConstructorExpr` with `#[derive(PartialEq)]`
    |
202 + #[derive(PartialEq)]
203 | pub struct TypeConstructorExpr {
    |

error[E0369]: binary operation `==` cannot be applied to type `&GroupedExpr`
   --> ast/nodes.rs:51:13
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 51 |     Grouped(GroupedExpr);
    |             ^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `GroupedExpr`
   --> ast/nodes.rs:209:1
    |
209 | pub struct GroupedExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `GroupedExpr` with `#[derive(PartialEq)]`
    |
209 + #[derive(PartialEq)]
210 | pub struct GroupedExpr {
    |

error[E0277]: can't compare `nodes::LiteralExpr` with `_`
   --> ast/nodes.rs:37:13
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
 36 | pub enum Expression {
 37 |     Literal(LiteralExpr),
    |             ^^^^^^^^^^^ no implementation for `nodes::LiteralExpr < _` and `nodes::LiteralExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::LiteralExpr`
   --> ast/nodes.rs:107:1
    |
107 | pub struct LiteralExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::IdentifierExpr` with `_`
   --> ast/nodes.rs:38:16
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 38 |     Identifier(IdentifierExpr),
    |                ^^^^^^^^^^^^^^ no implementation for `nodes::IdentifierExpr < _` and `nodes::IdentifierExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::IdentifierExpr`
   --> ast/nodes.rs:114:1
    |
114 | pub struct IdentifierExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::BinaryOpExpr` with `_`
   --> ast/nodes.rs:39:14
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 39 |     BinaryOp(BinaryOpExpr),
    |              ^^^^^^^^^^^^ no implementation for `nodes::BinaryOpExpr < _` and `nodes::BinaryOpExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::BinaryOpExpr`
   --> ast/nodes.rs:120:1
    |
120 | pub struct BinaryOpExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::UnaryOpExpr` with `_`
   --> ast/nodes.rs:40:13
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 40 |     UnaryOp(UnaryOpExpr),
    |             ^^^^^^^^^^^ no implementation for `nodes::UnaryOpExpr < _` and `nodes::UnaryOpExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::UnaryOpExpr`
   --> ast/nodes.rs:128:1
    |
128 | pub struct UnaryOpExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::CallExpr` with `_`
   --> ast/nodes.rs:41:10
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 41 |     Call(CallExpr),
    |          ^^^^^^^^ no implementation for `nodes::CallExpr < _` and `nodes::CallExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::CallExpr`
   --> ast/nodes.rs:135:1
    |
135 | pub struct CallExpr {
    | ^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::IndexExpr` with `_`
   --> ast/nodes.rs:42:11
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 42 |     Index(IndexExpr),
    |           ^^^^^^^^^ no implementation for `nodes::IndexExpr < _` and `nodes::IndexExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::IndexExpr`
   --> ast/nodes.rs:143:1
    |
143 | pub struct IndexExpr {
    | ^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::AttributeExpr` with `_`
   --> ast/nodes.rs:43:15
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 43 |     Attribute(AttributeExpr),
    |               ^^^^^^^^^^^^^ no implementation for `nodes::AttributeExpr < _` and `nodes::AttributeExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::AttributeExpr`
   --> ast/nodes.rs:150:1
    |
150 | pub struct AttributeExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::ListExpr` with `_`
   --> ast/nodes.rs:44:10
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 44 |     List(ListExpr),
    |          ^^^^^^^^ no implementation for `nodes::ListExpr < _` and `nodes::ListExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::ListExpr`
   --> ast/nodes.rs:157:1
    |
157 | pub struct ListExpr {
    | ^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::TupleExpr` with `_`
   --> ast/nodes.rs:45:11
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 45 |     Tuple(TupleExpr),
    |           ^^^^^^^^^ no implementation for `nodes::TupleExpr < _` and `nodes::TupleExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::TupleExpr`
   --> ast/nodes.rs:163:1
    |
163 | pub struct TupleExpr {
    | ^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::SetExpr` with `_`
   --> ast/nodes.rs:46:9
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 46 |     Set(SetExpr),
    |         ^^^^^^^ no implementation for `nodes::SetExpr < _` and `nodes::SetExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::SetExpr`
   --> ast/nodes.rs:169:1
    |
169 | pub struct SetExpr {
    | ^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::DictExpr` with `_`
   --> ast/nodes.rs:47:10
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 47 |     Dict(DictExpr),
    |          ^^^^^^^^ no implementation for `nodes::DictExpr < _` and `nodes::DictExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::DictExpr`
   --> ast/nodes.rs:175:1
    |
175 | pub struct DictExpr {
    | ^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `LambdaExpr` with `_`
   --> ast/nodes.rs:48:12
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 48 |     Lambda(LambdaExpr),
    |            ^^^^^^^^^^ no implementation for `LambdaExpr < _` and `LambdaExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `LambdaExpr`
   --> ast/nodes.rs:181:1
    |
181 | pub struct LambdaExpr {
    | ^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `MatchExpr` with `_`
   --> ast/nodes.rs:49:11
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 49 |     Match(MatchExpr),
    |           ^^^^^^^^^ no implementation for `MatchExpr < _` and `MatchExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `MatchExpr`
   --> ast/nodes.rs:188:1
    |
188 | pub struct MatchExpr {
    | ^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::TypeConstructorExpr` with `_`
   --> ast/nodes.rs:50:21
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 50 |     TypeConstructor(TypeConstructorExpr),
    |                     ^^^^^^^^^^^^^^^^^^^ no implementation for `nodes::TypeConstructorExpr < _` and `nodes::TypeConstructorExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::TypeConstructorExpr`
   --> ast/nodes.rs:202:1
    |
202 | pub struct TypeConstructorExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `GroupedExpr` with `_`
   --> ast/nodes.rs:51:13
    |
 35 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 51 |     Grouped(GroupedExpr);
    |             ^^^^^^^^^^^ no implementation for `GroupedExpr < _` and `GroupedExpr > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `GroupedExpr`
   --> ast/nodes.rs:209:1
    |
209 | pub struct GroupedExpr {
    | ^^^^^^^^^^^^^^^^^^^^^^

error[E0369]: binary operation `==` cannot be applied to type `&nodes::LetStmt`
   --> ast/nodes.rs:57:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
 56 | pub enum Statement {
 57 |     LetDecl(LetStmt),
    |             ^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::LetStmt`
   --> ast/nodes.rs:216:1
    |
216 | pub struct LetStmt {
    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::LetStmt` with `#[derive(PartialEq)]`
    |
216 + #[derive(PartialEq)]
217 | pub struct LetStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::VarStmt`
   --> ast/nodes.rs:58:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 58 |     VarDecl(VarStmt),
    |             ^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::VarStmt`
   --> ast/nodes.rs:224:1
    |
224 | pub struct VarStmt {
    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::VarStmt` with `#[derive(PartialEq)]`
    |
224 + #[derive(PartialEq)]
225 | pub struct VarStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::FunctionDecl`
   --> ast/nodes.rs:59:18
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 59 |     FunctionDecl(FunctionDecl),
    |                  ^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::FunctionDecl`
   --> ast/nodes.rs:240:1
    |
240 | pub struct FunctionDecl {
    | ^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::FunctionDecl` with `#[derive(PartialEq)]`
    |
240 + #[derive(PartialEq)]
241 | pub struct FunctionDecl {
    |

error[E0369]: binary operation `==` cannot be applied to type `&StructDecl`
   --> ast/nodes.rs:60:16
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 60 |     StructDecl(StructDecl),
    |                ^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `StructDecl`
   --> ast/nodes.rs:259:1
    |
259 | pub struct StructDecl {
    | ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `StructDecl` with `#[derive(PartialEq)]`
    |
259 + #[derive(PartialEq)]
260 | pub struct StructDecl {
    |

error[E0369]: binary operation `==` cannot be applied to type `&EnumDecl`
   --> ast/nodes.rs:61:14
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 61 |     EnumDecl(EnumDecl),
    |              ^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `EnumDecl`
   --> ast/nodes.rs:273:1
    |
273 | pub struct EnumDecl {
    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `EnumDecl` with `#[derive(PartialEq)]`
    |
273 + #[derive(PartialEq)]
274 | pub struct EnumDecl {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::IfStmt`
   --> ast/nodes.rs:62:12
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 62 |     IfStmt(IfStmt),
    |            ^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::IfStmt`
   --> ast/nodes.rs:280:1
    |
280 | pub struct IfStmt {
    | ^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::IfStmt` with `#[derive(PartialEq)]`
    |
280 + #[derive(PartialEq)]
281 | pub struct IfStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::WhileStmt`
   --> ast/nodes.rs:63:15
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 63 |     WhileStmt(WhileStmt),
    |               ^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::WhileStmt`
   --> ast/nodes.rs:295:1
    |
295 | pub struct WhileStmt {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::WhileStmt` with `#[derive(PartialEq)]`
    |
295 + #[derive(PartialEq)]
296 | pub struct WhileStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::ForStmt`
   --> ast/nodes.rs:64:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 64 |     ForStmt(ForStmt),
    |             ^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::ForStmt`
   --> ast/nodes.rs:302:1
    |
302 | pub struct ForStmt {
    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::ForStmt` with `#[derive(PartialEq)]`
    |
302 + #[derive(PartialEq)]
303 | pub struct ForStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&LoopStmt`
   --> ast/nodes.rs:65:14
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 65 |     LoopStmt(LoopStmt),
    |              ^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `LoopStmt`
   --> ast/nodes.rs:310:1
    |
310 | pub struct LoopStmt {
    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `LoopStmt` with `#[derive(PartialEq)]`
    |
310 + #[derive(PartialEq)]
311 | pub struct LoopStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&MatchStmt`
   --> ast/nodes.rs:66:15
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 66 |     MatchStmt(MatchStmt),
    |               ^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `MatchStmt`
   --> ast/nodes.rs:316:1
    |
316 | pub struct MatchStmt {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `MatchStmt` with `#[derive(PartialEq)]`
    |
316 + #[derive(PartialEq)]
317 | pub struct MatchStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&BreakStmt`
   --> ast/nodes.rs:67:15
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 67 |     BreakStmt(BreakStmt),
    |               ^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `BreakStmt`
   --> ast/nodes.rs:330:1
    |
330 | pub struct BreakStmt {
    | ^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `BreakStmt` with `#[derive(PartialEq)]`
    |
330 + #[derive(PartialEq)]
331 | pub struct BreakStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&ContinueStmt`
   --> ast/nodes.rs:68:18
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 68 |     ContinueStmt(ContinueStmt),
    |                  ^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `ContinueStmt`
   --> ast/nodes.rs:335:1
    |
335 | pub struct ContinueStmt {
    | ^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `ContinueStmt` with `#[derive(PartialEq)]`
    |
335 + #[derive(PartialEq)]
336 | pub struct ContinueStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::ReturnStmt`
   --> ast/nodes.rs:69:16
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 69 |     ReturnStmt(ReturnStmt),
    |                ^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::ReturnStmt`
   --> ast/nodes.rs:340:1
    |
340 | pub struct ReturnStmt {
    | ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::ReturnStmt` with `#[derive(PartialEq)]`
    |
340 + #[derive(PartialEq)]
341 | pub struct ReturnStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&TryStmt`
   --> ast/nodes.rs:70:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 70 |     TryStmt(TryStmt),
    |             ^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `TryStmt`
   --> ast/nodes.rs:346:1
    |
346 | pub struct TryStmt {
    | ^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `TryStmt` with `#[derive(PartialEq)]`
    |
346 + #[derive(PartialEq)]
347 | pub struct TryStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::ExpressionStmt`
   --> ast/nodes.rs:71:20
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 71 |     ExpressionStmt(ExpressionStmt),
    |                    ^^^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::ExpressionStmt`
   --> ast/nodes.rs:376:1
    |
376 | pub struct ExpressionStmt {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::ExpressionStmt` with `#[derive(PartialEq)]`
    |
376 + #[derive(PartialEq)]
377 | pub struct ExpressionStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::AssignmentStmt`
   --> ast/nodes.rs:72:20
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 72 |     AssignmentStmt(AssignmentStmt),
    |                    ^^^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::AssignmentStmt`
   --> ast/nodes.rs:232:1
    |
232 | pub struct AssignmentStmt {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::AssignmentStmt` with `#[derive(PartialEq)]`
    |
232 + #[derive(PartialEq)]
233 | pub struct AssignmentStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&nodes::ImportStmt`
   --> ast/nodes.rs:73:16
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 73 |     ImportStmt(ImportStmt),
    |                ^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `nodes::ImportStmt`
   --> ast/nodes.rs:361:1
    |
361 | pub struct ImportStmt {
    | ^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `nodes::ImportStmt` with `#[derive(PartialEq)]`
    |
361 + #[derive(PartialEq)]
362 | pub struct ImportStmt {
    |

error[E0369]: binary operation `==` cannot be applied to type `&ForeignCodeBlock`
   --> ast/nodes.rs:74:22
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 74 |     ForeignCodeBlock(ForeignCodeBlock),
    |                      ^^^^^^^^^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `ForeignCodeBlock`
   --> ast/nodes.rs:369:1
    |
369 | pub struct ForeignCodeBlock {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `ForeignCodeBlock` with `#[derive(PartialEq)]`
    |
369 + #[derive(PartialEq)]
370 | pub struct ForeignCodeBlock {
    |

error[E0369]: binary operation `==` cannot be applied to type `&PassStmt`
   --> ast/nodes.rs:75:14
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                        --------- in this derive macro expansion
...
 75 |     PassStmt(PassStmt);
    |              ^^^^^^^^
    |
note: an implementation of `PartialEq` might be missing for `PassStmt`
   --> ast/nodes.rs:382:1
    |
382 | pub struct PassStmt {
    | ^^^^^^^^^^^^^^^^^^^ must implement `PartialEq`
help: consider annotating `PassStmt` with `#[derive(PartialEq)]`
    |
382 + #[derive(PartialEq)]
383 | pub struct PassStmt {
    |

error[E0277]: can't compare `nodes::LetStmt` with `_`
   --> ast/nodes.rs:57:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
 56 | pub enum Statement {
 57 |     LetDecl(LetStmt),
    |             ^^^^^^^ no implementation for `nodes::LetStmt < _` and `nodes::LetStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::LetStmt`
   --> ast/nodes.rs:216:1
    |
216 | pub struct LetStmt {
    | ^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::VarStmt` with `_`
   --> ast/nodes.rs:58:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 58 |     VarDecl(VarStmt),
    |             ^^^^^^^ no implementation for `nodes::VarStmt < _` and `nodes::VarStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::VarStmt`
   --> ast/nodes.rs:224:1
    |
224 | pub struct VarStmt {
    | ^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::FunctionDecl` with `_`
   --> ast/nodes.rs:59:18
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 59 |     FunctionDecl(FunctionDecl),
    |                  ^^^^^^^^^^^^ no implementation for `nodes::FunctionDecl < _` and `nodes::FunctionDecl > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::FunctionDecl`
   --> ast/nodes.rs:240:1
    |
240 | pub struct FunctionDecl {
    | ^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `StructDecl` with `_`
   --> ast/nodes.rs:60:16
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 60 |     StructDecl(StructDecl),
    |                ^^^^^^^^^^ no implementation for `StructDecl < _` and `StructDecl > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `StructDecl`
   --> ast/nodes.rs:259:1
    |
259 | pub struct StructDecl {
    | ^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `EnumDecl` with `_`
   --> ast/nodes.rs:61:14
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 61 |     EnumDecl(EnumDecl),
    |              ^^^^^^^^ no implementation for `EnumDecl < _` and `EnumDecl > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `EnumDecl`
   --> ast/nodes.rs:273:1
    |
273 | pub struct EnumDecl {
    | ^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::IfStmt` with `_`
   --> ast/nodes.rs:62:12
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 62 |     IfStmt(IfStmt),
    |            ^^^^^^ no implementation for `nodes::IfStmt < _` and `nodes::IfStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::IfStmt`
   --> ast/nodes.rs:280:1
    |
280 | pub struct IfStmt {
    | ^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::WhileStmt` with `_`
   --> ast/nodes.rs:63:15
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 63 |     WhileStmt(WhileStmt),
    |               ^^^^^^^^^ no implementation for `nodes::WhileStmt < _` and `nodes::WhileStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::WhileStmt`
   --> ast/nodes.rs:295:1
    |
295 | pub struct WhileStmt {
    | ^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::ForStmt` with `_`
   --> ast/nodes.rs:64:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 64 |     ForStmt(ForStmt),
    |             ^^^^^^^ no implementation for `nodes::ForStmt < _` and `nodes::ForStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::ForStmt`
   --> ast/nodes.rs:302:1
    |
302 | pub struct ForStmt {
    | ^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `LoopStmt` with `_`
   --> ast/nodes.rs:65:14
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 65 |     LoopStmt(LoopStmt),
    |              ^^^^^^^^ no implementation for `LoopStmt < _` and `LoopStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `LoopStmt`
   --> ast/nodes.rs:310:1
    |
310 | pub struct LoopStmt {
    | ^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `MatchStmt` with `_`
   --> ast/nodes.rs:66:15
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 66 |     MatchStmt(MatchStmt),
    |               ^^^^^^^^^ no implementation for `MatchStmt < _` and `MatchStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `MatchStmt`
   --> ast/nodes.rs:316:1
    |
316 | pub struct MatchStmt {
    | ^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `BreakStmt` with `_`
   --> ast/nodes.rs:67:15
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 67 |     BreakStmt(BreakStmt),
    |               ^^^^^^^^^ no implementation for `BreakStmt < _` and `BreakStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `BreakStmt`
   --> ast/nodes.rs:330:1
    |
330 | pub struct BreakStmt {
    | ^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `ContinueStmt` with `_`
   --> ast/nodes.rs:68:18
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 68 |     ContinueStmt(ContinueStmt),
    |                  ^^^^^^^^^^^^ no implementation for `ContinueStmt < _` and `ContinueStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `ContinueStmt`
   --> ast/nodes.rs:335:1
    |
335 | pub struct ContinueStmt {
    | ^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::ReturnStmt` with `_`
   --> ast/nodes.rs:69:16
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 69 |     ReturnStmt(ReturnStmt),
    |                ^^^^^^^^^^ no implementation for `nodes::ReturnStmt < _` and `nodes::ReturnStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::ReturnStmt`
   --> ast/nodes.rs:340:1
    |
340 | pub struct ReturnStmt {
    | ^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `TryStmt` with `_`
   --> ast/nodes.rs:70:13
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 70 |     TryStmt(TryStmt),
    |             ^^^^^^^ no implementation for `TryStmt < _` and `TryStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `TryStmt`
   --> ast/nodes.rs:346:1
    |
346 | pub struct TryStmt {
    | ^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::ExpressionStmt` with `_`
   --> ast/nodes.rs:71:20
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 71 |     ExpressionStmt(ExpressionStmt),
    |                    ^^^^^^^^^^^^^^ no implementation for `nodes::ExpressionStmt < _` and `nodes::ExpressionStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::ExpressionStmt`
   --> ast/nodes.rs:376:1
    |
376 | pub struct ExpressionStmt {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::AssignmentStmt` with `_`
   --> ast/nodes.rs:72:20
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 72 |     AssignmentStmt(AssignmentStmt),
    |                    ^^^^^^^^^^^^^^ no implementation for `nodes::AssignmentStmt < _` and `nodes::AssignmentStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::AssignmentStmt`
   --> ast/nodes.rs:232:1
    |
232 | pub struct AssignmentStmt {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `nodes::ImportStmt` with `_`
   --> ast/nodes.rs:73:16
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 73 |     ImportStmt(ImportStmt),
    |                ^^^^^^^^^^ no implementation for `nodes::ImportStmt < _` and `nodes::ImportStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `nodes::ImportStmt`
   --> ast/nodes.rs:361:1
    |
361 | pub struct ImportStmt {
    | ^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `ForeignCodeBlock` with `_`
   --> ast/nodes.rs:74:22
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 74 |     ForeignCodeBlock(ForeignCodeBlock),
    |                      ^^^^^^^^^^^^^^^^ no implementation for `ForeignCodeBlock < _` and `ForeignCodeBlock > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `ForeignCodeBlock`
   --> ast/nodes.rs:369:1
    |
369 | pub struct ForeignCodeBlock {
    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0277]: can't compare `PassStmt` with `_`
   --> ast/nodes.rs:75:14
    |
 55 | #[derive(Debug, Clone, PartialEq, PartialOrd)]
    |                                   ---------- in this derive macro expansion
...
 75 |     PassStmt(PassStmt);
    |              ^^^^^^^^ no implementation for `PassStmt < _` and `PassStmt > _`
    |
help: the trait `PartialOrd<_>` is not implemented for `PassStmt`
   --> ast/nodes.rs:382:1
    |
382 | pub struct PassStmt {
    | ^^^^^^^^^^^^^^^^^^^

error[E0277]: the type `str` cannot be indexed by `usize`
  --> builtins/codegen_helpers.rs:17:20
   |
17 |         let ch = s[i];
   |                    ^ string indices are ranges of `usize`
   |
   = help: the trait `SliceIndex<str>` is not implemented for `usize`
   = help: the following other types implement trait `SliceIndex<T>`:
             `usize` implements `SliceIndex<ByteStr>`
             `usize` implements `SliceIndex<[T]>`
   = note: required for `String` to implement `Index<usize>`

error[E0277]: the type `str` cannot be indexed by `usize`
  --> builtins/codegen_helpers.rs:20:30
   |
20 |                 let next = s[i + 1];
   |                              ^^^^^ string indices are ranges of `usize`
   |
   = help: the trait `SliceIndex<str>` is not implemented for `usize`
   = help: the following other types implement trait `SliceIndex<T>`:
             `usize` implements `SliceIndex<ByteStr>`
             `usize` implements `SliceIndex<[T]>`
   = note: required for `String` to implement `Index<usize>`

error[E0369]: cannot add `&str` to `&str`
  --> builtins/codegen_helpers.rs:23:37
   |
23 |                     result = result + "\\n";
   |                              ------ ^ ----- &str
   |                              |      |
   |                              |      `+` cannot be used to concatenate two `&str` strings
   |                              &str
   |
   = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
   |
23 |                     result = result.to_owned() + "\\n";
   |                                    +++++++++++

error[E0369]: cannot add `&str` to `&str`
  --> builtins/codegen_helpers.rs:27:37
   |
27 |                     result = result + "\\t";
   |                              ------ ^ ----- &str
   |                              |      |
   |                              |      `+` cannot be used to concatenate two `&str` strings
   |                              &str
   |
   = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
   |
27 |                     result = result.to_owned() + "\\t";
   |                                    +++++++++++

error[E0369]: cannot add `&str` to `&str`
  --> builtins/codegen_helpers.rs:31:37
   |
31 |                     result = result + "\\r";
   |                              ------ ^ ----- &str
   |                              |      |
   |                              |      `+` cannot be used to concatenate two `&str` strings
   |                              &str
   |
   = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
   |
31 |                     result = result.to_owned() + "\\r";
   |                                    +++++++++++

error[E0369]: cannot add `&str` to `&str`
  --> builtins/codegen_helpers.rs:35:37
   |
35 |                     result = result + "\\\\";
   |                              ------ ^ ------ &str
   |                              |      |
   |                              |      `+` cannot be used to concatenate two `&str` strings
   |                              &str
   |
   = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
   |
35 |                     result = result.to_owned() + "\\\\";
   |                                    +++++++++++

error[E0369]: cannot add `&str` to `&str`
  --> builtins/codegen_helpers.rs:39:37
   |
39 |                     result = result + "\\\"";
   |                              ------ ^ ------ &str
   |                              |      |
   |                              |      `+` cannot be used to concatenate two `&str` strings
   |                              &str
   |
   = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
   |
39 |                     result = result.to_owned() + "\\\"";
   |                                    +++++++++++

error[E0369]: cannot add `_` to `&str`
  --> builtins/codegen_helpers.rs:43:37
   |
43 |                     result = result + ch;
   |                              ------ ^ -- _
   |                              |
   |                              &str

error[E0369]: cannot add `_` to `&str`
  --> builtins/codegen_helpers.rs:48:33
   |
48 |                 result = result + ch;
   |                          ------ ^ -- _
   |                          |
   |                          &str

error[E0369]: cannot add `_` to `&str`
  --> builtins/codegen_helpers.rs:53:29
   |
53 |             result = result + ch;
   |                      ------ ^ -- _
   |                      |
   |                      &str

error[E0308]: mismatched types
  --> builtins/codegen_helpers.rs:58:12
   |
10 | pub fn escape_string(s: String)  ->  String {
   |                                      ------ expected `String` because of return type
...
58 |     return result;
   |            ^^^^^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
58 |     return result.to_string();
   |                  ++++++++++++

error[E0599]: no method named `startswith` found for struct `String` in the current scope
   --> builtins/codegen_helpers.rs:100:17
    |
100 |     if type_str.startswith("Vec[".to_string().to_string()) {
    |                 ^^^^^^^^^^
    |
help: there is a method `starts_with` with a similar name
    |
100 |     if type_str.starts_with("Vec[".to_string().to_string()) {
    |                       +

error[E0599]: no method named `substring` found for struct `String` in the current scope
    --> builtins/codegen_helpers.rs:101:30
     |
 101 |         let inner = type_str.substring(6, (type_str).len() - 1);
     |                              ^^^^^^^^^
     |
help: there is a method `to_string` with a similar name, but with different arguments
    --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2855:5
     |
2855 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:102:37
    |
102 |         return "Vec<".to_string() + gul_type_to_rust(inner) + ">";
    |                                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
102 |         return "Vec<".to_string() + &gul_type_to_rust(inner) + ">";
    |                                     +

error[E0599]: no method named `startswith` found for struct `String` in the current scope
   --> builtins/codegen_helpers.rs:104:22
    |
104 |     else if type_str.startswith("HashMap[".to_string().to_string()) {
    |                      ^^^^^^^^^^
    |
help: there is a method `starts_with` with a similar name
    |
104 |     else if type_str.starts_with("HashMap[".to_string().to_string()) {
    |                            +

error[E0599]: no method named `substring` found for struct `String` in the current scope
    --> builtins/codegen_helpers.rs:105:30
     |
 105 |         let inner = type_str.substring(6, (type_str).len() - 1);
     |                              ^^^^^^^^^
     |
help: there is a method `to_string` with a similar name, but with different arguments
    --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:2855:5
     |
2855 |     fn to_string(&self) -> String;
     |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:136:42
    |
136 |     let mut result = "fn ".to_string() + name + "(";
    |                                          ^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
136 |     let mut result = "fn ".to_string() + &name + "(";
    |                                          +

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:139:27
    |
139 |         result = result + self_param_to_rust(receiver);
    |                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
139 |         result = result + &self_param_to_rust(receiver);
    |                           +

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:150:27
    |
150 |         result = result + p;
    |                           ^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
150 |         result = result + &p;
    |                           +

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:157:27
    |
157 |         result = result + " -> ".to_string() + &gul_type_to_rust(return_type);
    |                           ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
157 -         result = result + " -> ".to_string() + &gul_type_to_rust(return_type);
157 +         result = result + " -> " + &gul_type_to_rust(return_type);
    |

error[E0369]: cannot add `&str` to `&str`
   --> builtins/codegen_helpers.rs:172:25
    |
172 |         indent = indent + "    ";
    |                  ------ ^ ------ &str
    |                  |      |
    |                  |      `+` cannot be used to concatenate two `&str` strings
    |                  &str
    |
    = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
    |
172 |         indent = indent.to_owned() + "    ";
    |                        +++++++++++

error[E0277]: the trait bound `String: Pattern` is not satisfied
    --> builtins/codegen_helpers.rs:177:28
     |
 177 |     let lines = code.split("\n".to_string().to_string());
     |                      ----- ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `Pattern` is not implemented for `String`
     |                      |
     |                      required by a bound introduced by this call
     |
     = note: required for `String` to implement `Pattern`
note: required by a bound in `core::str::<impl str>::split`
    --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/mod.rs:1628:21
     |
1628 |     pub fn split<P: Pattern>(&self, pat: P) -> Split<'_, P> {
     |                     ^^^^^^^ required by this bound in `core::str::<impl str>::split`
help: consider borrowing here
     |
 177 |     let lines = code.split(&"\n".to_string().to_string());
     |                            +

error[E0277]: expected a `FnMut(char)` closure, found `String`
   --> builtins/codegen_helpers.rs:178:17
    |
178 |     for line in lines {
    |                 ^^^^^ expected an `FnMut(char)` closure, found `String`
    |
    = help: the trait `FnMut(char)` is not implemented for `String`
    = help: the trait `Pattern` is implemented for `&String`
    = note: required for `String` to implement `Pattern`
note: required by a bound in `std::str::Split`
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/str/iter.rs:789:1
    |
789 | / generate_pattern_iterators! {
790 | |     forward:
791 | |         /// Created with the method [`split`].
792 | |         ///
793 | |         /// [`split`]: str::split
794 | |         struct Split;
    | |                ----- required by a bound in this struct
...   |
804 | |     delegate double ended;
805 | | }
    | |_^ required by this bound in `Split`
    = note: this error originates in the macro `generate_pattern_iterators` (in Nightly builds, run with -Z macro-backtrace for more info)

error[E0369]: cannot add `&str` to `&str`
   --> builtins/codegen_helpers.rs:180:29
    |
180 |             result = result + indent + line + "\n";
    |                      ------ ^ ------ &str
    |                      |      |
    |                      |      `+` cannot be used to concatenate two `&str` strings
    |                      &str
    |
    = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
    |
180 |             result = result.to_owned() + indent + line + "\n";
    |                            +++++++++++

error[E0369]: cannot add `&str` to `&str`
   --> builtins/codegen_helpers.rs:183:29
    |
183 |             result = result + "\n";
    |                      ------ ^ ---- &str
    |                      |      |
    |                      |      `+` cannot be used to concatenate two `&str` strings
    |                      &str
    |
    = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
    |
183 |             result = result.to_owned() + "\n";
    |                            +++++++++++

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:187:12
    |
167 | pub fn indent_code(code: String, level: usize)  ->  String {
    |                                                     ------ expected `String` because of return type
...
187 |     return result;
    |            ^^^^^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
187 |     return result.to_string();
    |                  ++++++++++++

error[E0308]: mismatched types
   --> builtins/codegen_helpers.rs:192:32
    |
192 |     return "{\n".to_string() + code + "}\n";
    |                                ^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
192 |     return "{\n".to_string() + &code + "}\n";
    |                                +

error[E0425]: cannot find function `to_string` in this scope
  --> codegen/rust_backend.rs:40:41
   |
40 |         self.output.push(format!("{}{}".to_string(), indent_str, code));
   |                                         ^^^^^^^^^ not found in this scope

error[E0599]: no method named `join` found for struct `String` in the current scope
  --> codegen/rust_backend.rs:50:33
   |
50 |         return "\n".to_string().join(self.output);
   |                                 ^^^^ method not found in `String`

error[E0308]: mismatched types
  --> codegen/rust_backend.rs:61:23
   |
61 |         self.emit_raw("");
   |              -------- ^^ expected `String`, found `&str`
   |              |
   |              arguments to this method are incorrect
   |
note: method defined here
  --> codegen/rust_backend.rs:43:12
   |
43 |     pub fn emit_raw(&mut self, code: String) {
   |            ^^^^^^^^            ------------
help: try using a conversion method
   |
61 |         self.emit_raw("".to_string());
   |                         ++++++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:65:34
    |
 65 |             self.generate_import(import_stmt);
    |                  --------------- ^^^^^^^^^^^ expected `&ImportStmt`, found `ImportStmt`
    |                  |
    |                  arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:249:12
    |
249 |     pub fn generate_import(&mut self, stmt: &ImportStmt) {
    |            ^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
 65 |             self.generate_import(&import_stmt);
    |                                  +

error[E0308]: mismatched types
  --> codegen/rust_backend.rs:69:27
   |
69 |             self.emit_raw("");
   |                  -------- ^^ expected `String`, found `&str`
   |                  |
   |                  arguments to this method are incorrect
   |
note: method defined here
  --> codegen/rust_backend.rs:43:12
   |
43 |     pub fn emit_raw(&mut self, code: String) {
   |            ^^^^^^^^            ------------
help: try using a conversion method
   |
69 |             self.emit_raw("".to_string());
   |                             ++++++++++++

error[E0308]: mismatched types
  --> codegen/rust_backend.rs:74:37
   |
74 |             self.generate_statement(stmt);
   |                  ------------------ ^^^^ expected `&Statement`, found `Statement`
   |                  |
   |                  arguments to this method are incorrect
   |
note: method defined here
  --> codegen/rust_backend.rs:94:12
   |
94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
   |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
   |
74 |             self.generate_statement(&stmt);
   |                                     +

error[E0308]: mismatched types
  --> codegen/rust_backend.rs:79:27
   |
79 |             self.emit_raw("");
   |                  -------- ^^ expected `String`, found `&str`
   |                  |
   |                  arguments to this method are incorrect
   |
note: method defined here
  --> codegen/rust_backend.rs:43:12
   |
43 |     pub fn emit_raw(&mut self, code: String) {
   |            ^^^^^^^^            ------------
help: try using a conversion method
   |
79 |             self.emit_raw("".to_string());
   |                             ++++++++++++

error[E0308]: mismatched types
  --> codegen/rust_backend.rs:83:41
   |
83 |                 self.generate_statement(stmt);
   |                      ------------------ ^^^^ expected `&Statement`, found `Statement`
   |                      |
   |                      arguments to this method are incorrect
   |
note: method defined here
  --> codegen/rust_backend.rs:94:12
   |
94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
   |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
   |
83 |                 self.generate_statement(&stmt);
   |                                         +

error[E0425]: cannot find function `to_string` in this scope
   --> codegen/rust_backend.rs:114:41
    |
114 |         let mut code = format!("let {}".to_string(), stmt.name);
    |                                         ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:115:12
    |
115 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0425]: cannot find function `to_string` in this scope
   --> codegen/rust_backend.rs:115:59
    |
115 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |                                                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> codegen/rust_backend.rs:116:35
    |
116 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                                   ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:116:83
    |
116 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                                                           ----------------------- ^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                                                           |
    |                                                           arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
116 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(&stmt.value));
    |                                                                                   +

error[E0425]: cannot find function `to_string` in this scope
   --> codegen/rust_backend.rs:122:45
    |
122 |         let mut code = format!("let mut {}".to_string(), stmt.name);
    |                                             ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:123:12
    |
123 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0425]: cannot find function `to_string` in this scope
   --> codegen/rust_backend.rs:123:59
    |
123 |         if stmt.type_annotation { code = format!("{}: {}".to_string(), code, self.map_type(stmt.type_annotation)) }
    |                                                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> codegen/rust_backend.rs:124:35
    |
124 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                                   ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:124:83
    |
124 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(stmt.value));
    |                                                           ----------------------- ^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                                                           |
    |                                                           arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
124 |         code = format!("{} = {};".to_string(), code, self.generate_expression_str(&stmt.value));
    |                                                                                   +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:130:49
    |
130 |         let mut signature = "fn ".to_string() + stmt.name + "(";
    |                                                 ^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
130 |         let mut signature = "fn ".to_string() + &stmt.name + "(";
    |                                                 +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:134:16
    |
134 |             if param.type_annotation { param_str = param_str + ": ".to_string() + &self.map_type(param.type_annotation) }
    |                ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:134:64
    |
134 |             if param.type_annotation { param_str = param_str + ": ".to_string() + &self.map_type(param.type_annotation) }
    |                                                                ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
134 -             if param.type_annotation { param_str = param_str + ": ".to_string() + &self.map_type(param.type_annotation) }
134 +             if param.type_annotation { param_str = param_str + ": " + &self.map_type(param.type_annotation) }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:137:33
    |
137 |         signature = signature + params.join(", ") + ".to_string())";
    |                                 ^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
137 |         signature = signature + &params.join(", ") + ".to_string())";
    |                                 +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:138:12
    |
138 |         if stmt.return_type { signature = signature + " -> ".to_string() + &self.map_type(stmt.return_type) }
    |            ^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:138:55
    |
138 |         if stmt.return_type { signature = signature + " -> ".to_string() + &self.map_type(stmt.return_type) }
    |                                                       ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
138 -         if stmt.return_type { signature = signature + " -> ".to_string() + &self.map_type(stmt.return_type) }
138 +         if stmt.return_type { signature = signature + " -> " + &self.map_type(stmt.return_type) }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:142:62
    |
142 |         for body_stmt in stmt.body { self.generate_statement(body_stmt) }
    |                                           ------------------ ^^^^^^^^^ expected `&Statement`, found `Statement`
    |                                           |
    |                                           arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:94:12
    |
 94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
    |
142 |         for body_stmt in stmt.body { self.generate_statement(&body_stmt) }
    |                                                              +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:145:23
    |
145 |         self.emit_raw("");
    |              -------- ^^ expected `String`, found `&str`
    |              |
    |              arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:43:12
    |
 43 |     pub fn emit_raw(&mut self, code: String) {
    |            ^^^^^^^^            ------------
help: try using a conversion method
    |
145 |         self.emit_raw("".to_string());
    |                         ++++++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:150:54
    |
150 |         let condition = self.generate_expression_str(stmt.condition);
    |                              ----------------------- ^^^^^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                              |
    |                              arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
150 |         let condition = self.generate_expression_str(&stmt.condition);
    |                                                      +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:151:39
    |
151 |         self.emit("if ".to_string() + condition + " {");
    |                                       ^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
151 |         self.emit("if ".to_string() + &condition + " {");
    |                                       +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:155:37
    |
155 |             self.generate_statement(s);
    |                  ------------------ ^ expected `&Statement`, found `Statement`
    |                  |
    |                  arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:94:12
    |
 94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
    |
155 |             self.generate_statement(&s);
    |                                     +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:161:58
    |
161 |             let elif_cond = self.generate_expression_str(elif_clause.condition);
    |                                  ----------------------- ^^^^^^^^^^^^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                                  |
    |                                  arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
161 |             let elif_cond = self.generate_expression_str(&elif_clause.condition);
    |                                                          +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:162:50
    |
162 |             self.emit("} else if ".to_string() + elif_cond + " {");
    |                                                  ^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
162 |             self.emit("} else if ".to_string() + &elif_cond + " {");
    |                                                  +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:165:41
    |
165 |                 self.generate_statement(s);
    |                      ------------------ ^ expected `&Statement`, found `Statement`
    |                      |
    |                      arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:94:12
    |
 94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
    |
165 |                 self.generate_statement(&s);
    |                                         +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:175:41
    |
175 |                 self.generate_statement(s);
    |                      ------------------ ^ expected `&Statement`, found `Statement`
    |                      |
    |                      arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:94:12
    |
 94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
    |
175 |                 self.generate_statement(&s);
    |                                         +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:185:54
    |
185 |         let condition = self.generate_expression_str(stmt.condition);
    |                              ----------------------- ^^^^^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                              |
    |                              arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
185 |         let condition = self.generate_expression_str(&stmt.condition);
    |                                                      +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:186:42
    |
186 |         self.emit("while ".to_string() + condition + " {");
    |                                          ^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
186 |         self.emit("while ".to_string() + &condition + " {");
    |                                          +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:190:37
    |
190 |             self.generate_statement(s);
    |                  ------------------ ^ expected `&Statement`, found `Statement`
    |                  |
    |                  arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:94:12
    |
 94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
    |
190 |             self.generate_statement(&s);
    |                                     +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:198:53
    |
198 |         let iterable = self.generate_expression_str(stmt.iterable);
    |                             ----------------------- ^^^^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                             |
    |                             arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
198 |         let iterable = self.generate_expression_str(&stmt.iterable);
    |                                                     +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:199:40
    |
199 |         self.emit("for ".to_string() + stmt.variable + " in ".to_string() + &iterable + " {");
    |                                        ^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
199 |         self.emit("for ".to_string() + &stmt.variable + " in ".to_string() + &iterable + " {");
    |                                        +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:199:56
    |
199 |         self.emit("for ".to_string() + stmt.variable + " in ".to_string() + &iterable + " {");
    |                                                        ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
199 -         self.emit("for ".to_string() + stmt.variable + " in ".to_string() + &iterable + " {");
199 +         self.emit("for ".to_string() + stmt.variable + " in " + &iterable + " {");
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:203:37
    |
203 |             self.generate_statement(s);
    |                  ------------------ ^ expected `&Statement`, found `Statement`
    |                  |
    |                  arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:94:12
    |
 94 |     pub fn generate_statement(&mut self, stmt: &Statement) {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider borrowing here
    |
203 |             self.generate_statement(&s);
    |                                     +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:211:12
    |
211 |         if stmt.value {
    |            ^^^^^^^^^^ expected `bool`, found `Expression`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:212:54
    |
212 |             let value = self.generate_expression_str(stmt.value);
    |                              ----------------------- ^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                              |
    |                              arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
212 |             let value = self.generate_expression_str(&stmt.value);
    |                                                      +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:213:47
    |
213 |             self.emit("return ".to_string() + value + ".to_string();");
    |                                               ^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
213 |             self.emit("return ".to_string() + &value + ".to_string();");
    |                                               +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:222:51
    |
222 |         let target = self.generate_expression_str(stmt.target);
    |                           ----------------------- ^^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                           |
    |                           arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
222 |         let target = self.generate_expression_str(&stmt.target);
    |                                                   +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:223:50
    |
223 |         let value = self.generate_expression_str(stmt.value);
    |                          ----------------------- ^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                          |
    |                          arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
223 |         let value = self.generate_expression_str(&stmt.value);
    |                                                  +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:240:28
    |
240 |         self.emit(target + " ".to_string() + &op + " ".to_string() + &value + ";");
    |                            ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
240 -         self.emit(target + " ".to_string() + &op + " ".to_string() + &value + ";");
240 +         self.emit(target + " " + &op + " ".to_string() + &value + ";");
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:240:52
    |
240 |         self.emit(target + " ".to_string() + &op + " ".to_string() + &value + ";");
    |                                                    ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
240 -         self.emit(target + " ".to_string() + &op + " ".to_string() + &value + ";");
240 +         self.emit(target + " ".to_string() + &op + " " + &value + ";");
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:245:49
    |
245 |         let expr = self.generate_expression_str(stmt.expression);
    |                         ----------------------- ^^^^^^^^^^^^^^^ expected `&Expression`, found `Expression`
    |                         |
    |                         arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
245 |         let expr = self.generate_expression_str(&stmt.expression);
    |                                                 +

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:251:39
    |
251 |         let module = "::".to_string().join(stmt.module_path);
    |                                       ^^^^ method not found in `String`

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:254:42
    |
254 |             let items = ", ".to_string().join(items);
    |                                          ^^^^ method not found in `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:255:57
    |
255 |             self.emit_raw("use ".to_string() + module + "::{".to_string() + &items + "};");
    |                                                         ^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
255 -             self.emit_raw("use ".to_string() + module + "::{".to_string() + &items + "};");
255 +             self.emit_raw("use ".to_string() + module + "::{" + &items + "};");
    |

error[E0599]: no variant or associated item named `StringLiteral` found for enum `token::TokenType` in the current scope
   --> codegen/rust_backend.rs:269:49
    |
269 |                 if lit.value_type == TokenType::StringLiteral { return self.generate_string_literal(lit) }
    |                                                 ^^^^^^^^^^^^^ variant or associated item not found in `token::TokenType`
    |
   ::: lexer/token.rs:8:1
    |
  8 | pub enum TokenType {
    | ------------------ variant or associated item `StringLiteral` not found for this enum

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:269:101
    |
269 |                 if lit.value_type == TokenType::StringLiteral { return self.generate_string_literal(lit) }
    |                                                                             ----------------------- ^^^ expected `LiteralExpr`, found `&LiteralExpr`
    |                                                                             |
    |                                                                             arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:294:12
    |
294 |     pub fn generate_string_literal(&mut self, expr: LiteralExpr)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider using clone here
    |
269 |                 if lit.value_type == TokenType::StringLiteral { return self.generate_string_literal(lit.clone()) }
    |                                                                                                        ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:270:53
    |
270 |                 else { return self.generate_literal(lit) }
    |                                    ---------------- ^^^ expected `LiteralExpr`, found `&LiteralExpr`
    |                                    |
    |                                    arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:289:12
    |
289 |     pub fn generate_literal(&mut self, expr: LiteralExpr)  ->  String {
    |            ^^^^^^^^^^^^^^^^            -----------------
help: consider using clone here
    |
270 |                 else { return self.generate_literal(lit.clone()) }
    |                                                        ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:271:75
    |
271 |             Expression::Identifier(id) => return self.generate_identifier(id),
    |                                                       ------------------- ^^ expected `IdentifierExpr`, found `&IdentifierExpr`
    |                                                       |
    |                                                       arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:299:12
    |
299 |     pub fn generate_identifier(&mut self, expr: IdentifierExpr)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^            --------------------
help: consider using clone here
    |
271 |             Expression::Identifier(id) => return self.generate_identifier(id.clone()),
    |                                                                             ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:272:72
    |
272 |             Expression::BinaryOp(op) => return self.generate_binary_op(op),
    |                                                     ------------------ ^^ expected `BinaryOpExpr`, found `&BinaryOpExpr`
    |                                                     |
    |                                                     arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:304:12
    |
304 |     pub fn generate_binary_op(&mut self, expr: BinaryOpExpr)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ------------------
help: consider using clone here
    |
272 |             Expression::BinaryOp(op) => return self.generate_binary_op(op.clone()),
    |                                                                          ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:273:70
    |
273 |             Expression::UnaryOp(op) => return self.generate_unary_op(op),
    |                                                    ----------------- ^^ expected `UnaryOpExpr`, found `&UnaryOpExpr`
    |                                                    |
    |                                                    arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:329:12
    |
329 |     pub fn generate_unary_op(&mut self, expr: UnaryOpExpr)  ->  String {
    |            ^^^^^^^^^^^^^^^^^            -----------------
help: consider using clone here
    |
273 |             Expression::UnaryOp(op) => return self.generate_unary_op(op.clone()),
    |                                                                        ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:274:65
    |
274 |             Expression::Call(call) => return self.generate_call(call),
    |                                                   ------------- ^^^^ expected `CallExpr`, found `&CallExpr`
    |                                                   |
    |                                                   arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:344:12
    |
344 |     pub fn generate_call(&mut self, expr: CallExpr)  ->  String {
    |            ^^^^^^^^^^^^^            --------------
help: consider using clone here
    |
274 |             Expression::Call(call) => return self.generate_call(call.clone()),
    |                                                                     ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:275:66
    |
275 |             Expression::Index(idx) => return self.generate_index(idx),
    |                                                   -------------- ^^^ expected `IndexExpr`, found `&IndexExpr`
    |                                                   |
    |                                                   arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:357:12
    |
357 |     pub fn generate_index(&mut self, expr: IndexExpr)  ->  String {
    |            ^^^^^^^^^^^^^^            ---------------
help: consider using clone here
    |
275 |             Expression::Index(idx) => return self.generate_index(idx.clone()),
    |                                                                     ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:276:75
    |
276 |             Expression::Attribute(attr) => return self.generate_attribute(attr),
    |                                                        ------------------ ^^^^ expected `AttributeExpr`, found `&AttributeExpr`
    |                                                        |
    |                                                        arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:364:12
    |
364 |     pub fn generate_attribute(&mut self, expr: AttributeExpr)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            -------------------
help: consider using clone here
    |
276 |             Expression::Attribute(attr) => return self.generate_attribute(attr.clone()),
    |                                                                               ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:277:62
    |
277 |             Expression::List(l) => return self.generate_list(l),
    |                                                ------------- ^ expected `ListExpr`, found `&ListExpr`
    |                                                |
    |                                                arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:370:12
    |
370 |     pub fn generate_list(&mut self, expr: ListExpr)  ->  String {
    |            ^^^^^^^^^^^^^            --------------
help: consider using clone here
    |
277 |             Expression::List(l) => return self.generate_list(l.clone()),
    |                                                               ++++++++

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:283:93
    |
283 |             Expression::Grouped(g) => return "(".to_string() + self.generate_expression_str(g.expression) + ".to_string().to_string())",
    |                                                                     ----------------------- ^^^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                                                                     |
    |                                                                     arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
283 |             Expression::Grouped(g) => return "(".to_string() + self.generate_expression_str(&g.expression) + ".to_string().to_string())",
    |                                                                                             +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:283:64
    |
283 |             Expression::Grouped(g) => return "(".to_string() + self.generate_expression_str(g.expression) + ".to_string().to_string())",
    |                                                                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
283 |             Expression::Grouped(g) => return "(".to_string() + &self.generate_expression_str(g.expression) + ".to_string().to_string())",
    |                                                                +

warning: unreachable statement
   --> codegen/rust_backend.rs:286:9
    |
267 | /         match expr {
268 | |             Expression::Literal(lit) =>
269 | |                 if lit.value_type == TokenType::StringLiteral { return self.generate_string_literal(lit) }
270 | |                 else { return self.generate_literal(lit) }
...   |
284 | |             _ => return "unknown_expr".to_string(),
285 | |         }
    | |_________- any code following this `match` expression is unreachable, as all arms diverge
286 |           return "/* unsupported expression */".to_string();
    |           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ unreachable statement
    |
    = note: `#[warn(unreachable_code)]` (part of `#[warn(unused)]`) on by default

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:305:49
    |
305 |         let left = self.generate_expression_str(expr.left);
    |                         ----------------------- ^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                         |
    |                         arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
305 |         let left = self.generate_expression_str(&expr.left);
    |                                                 +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:306:50
    |
306 |         let right = self.generate_expression_str(expr.right);
    |                          ----------------------- ^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                          |
    |                          arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
306 |         let right = self.generate_expression_str(&expr.right);
    |                                                  +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:309:43
    |
308 |         let mut op = "";
    |                      -- expected due to this value
309 |         if op_t == TokenType::Plus { op = "+".to_string() }
    |                                           ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
309 -         if op_t == TokenType::Plus { op = "+".to_string() }
309 +         if op_t == TokenType::Plus { op = "+" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:310:49
    |
308 |         let mut op = "";
    |                      -- expected due to this value
309 |         if op_t == TokenType::Plus { op = "+".to_string() }
310 |         else if op_t == TokenType::Minus { op = "-".to_string() }
    |                                                 ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
310 -         else if op_t == TokenType::Minus { op = "-".to_string() }
310 +         else if op_t == TokenType::Minus { op = "-" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:311:48
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
311 |         else if op_t == TokenType::Star { op = "*".to_string() }
    |                                                ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
311 -         else if op_t == TokenType::Star { op = "*".to_string() }
311 +         else if op_t == TokenType::Star { op = "*" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:312:49
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
312 |         else if op_t == TokenType::Slash { op = "/".to_string() }
    |                                                 ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
312 -         else if op_t == TokenType::Slash { op = "/".to_string() }
312 +         else if op_t == TokenType::Slash { op = "/" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:313:51
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
313 |         else if op_t == TokenType::Percent { op = "%".to_string() }
    |                                                   ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
313 -         else if op_t == TokenType::Percent { op = "%".to_string() }
313 +         else if op_t == TokenType::Percent { op = "%" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:314:63
    |
314 |         else if op_t == TokenType::DoubleStar { return left + ".pow(".to_string() + &right + ".to_string().to_string())" }
    |                                                               ^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
314 -         else if op_t == TokenType::DoubleStar { return left + ".pow(".to_string() + &right + ".to_string().to_string())" }
314 +         else if op_t == TokenType::DoubleStar { return left + ".pow(" + &right + ".to_string().to_string())" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:315:54
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
315 |         else if op_t == TokenType::EqualEqual { op = "==".to_string() }
    |                                                      ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
315 -         else if op_t == TokenType::EqualEqual { op = "==".to_string() }
315 +         else if op_t == TokenType::EqualEqual { op = "==" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:316:52
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
316 |         else if op_t == TokenType::NotEqual { op = "!=".to_string() }
    |                                                    ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
316 -         else if op_t == TokenType::NotEqual { op = "!=".to_string() }
316 +         else if op_t == TokenType::NotEqual { op = "!=" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:317:48
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
317 |         else if op_t == TokenType::Less { op = "<".to_string() }
    |                                                ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
317 -         else if op_t == TokenType::Less { op = "<".to_string() }
317 +         else if op_t == TokenType::Less { op = "<" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:318:51
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
318 |         else if op_t == TokenType::Greater { op = ">".to_string() }
    |                                                   ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
318 -         else if op_t == TokenType::Greater { op = ">".to_string() }
318 +         else if op_t == TokenType::Greater { op = ">" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:319:50
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
319 |         else if op_t == TokenType::LessEq { op = "<=".to_string() }
    |                                                  ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
319 -         else if op_t == TokenType::LessEq { op = "<=".to_string() }
319 +         else if op_t == TokenType::LessEq { op = "<=" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:320:53
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
320 |         else if op_t == TokenType::GreaterEq { op = ">=".to_string() }
    |                                                     ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
320 -         else if op_t == TokenType::GreaterEq { op = ">=".to_string() }
320 +         else if op_t == TokenType::GreaterEq { op = ">=" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:321:47
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
321 |         else if op_t == TokenType::And { op = "&&".to_string() }
    |                                               ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
321 -         else if op_t == TokenType::And { op = "&&".to_string() }
321 +         else if op_t == TokenType::And { op = "&&" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:322:46
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
322 |         else if op_t == TokenType::Or { op = "||".to_string() }
    |                                              ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
322 -         else if op_t == TokenType::Or { op = "||".to_string() }
322 +         else if op_t == TokenType::Or { op = "||" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:323:59
    |
323 |         else if op_t == TokenType::DotDot { return left + "..".to_string() + &right }
    |                                                           ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
323 -         else if op_t == TokenType::DotDot { return left + "..".to_string() + &right }
323 +         else if op_t == TokenType::DotDot { return left + ".." + &right }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:324:61
    |
324 |         else if op_t == TokenType::DotDotEq { return left + "..=".to_string() + &right }
    |                                                             ^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
324 -         else if op_t == TokenType::DotDotEq { return left + "..=".to_string() + &right }
324 +         else if op_t == TokenType::DotDotEq { return left + "..=" + &right }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:325:21
    |
308 |         let mut op = "";
    |                      -- expected due to this value
...
325 |         else { op = "?".to_string() }
    |                     ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
325 -         else { op = "?".to_string() }
325 +         else { op = "?" }
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:326:34
    |
326 |         return "(".to_string() + left + ".to_string() ".to_string() + &op + " ".to_string() + &right + ")";
    |                                  ^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
326 |         return "(".to_string() + &left + ".to_string() ".to_string() + &op + " ".to_string() + &right + ")";
    |                                  +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:326:41
    |
326 |         return "(".to_string() + left + ".to_string() ".to_string() + &op + " ".to_string() + &right + ")";
    |                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
326 -         return "(".to_string() + left + ".to_string() ".to_string() + &op + " ".to_string() + &right + ")";
326 +         return "(".to_string() + left + ".to_string() " + &op + " ".to_string() + &right + ")";
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:326:77
    |
326 |         return "(".to_string() + left + ".to_string() ".to_string() + &op + " ".to_string() + &right + ")";
    |                                                                             ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
326 -         return "(".to_string() + left + ".to_string() ".to_string() + &op + " ".to_string() + &right + ")";
326 +         return "(".to_string() + left + ".to_string() ".to_string() + &op + " " + &right + ")";
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:331:52
    |
331 |         let operand = self.generate_expression_str(expr.operand);
    |                            ----------------------- ^^^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                            |
    |                            arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
331 |         let operand = self.generate_expression_str(&expr.operand);
    |                                                    +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:334:38
    |
334 |             return "-".to_string() + operand;
    |                                      ^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
334 |             return "-".to_string() + &operand;
    |                                      +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:337:38
    |
337 |             return "!".to_string() + operand;
    |                                      ^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
337 |             return "!".to_string() + &operand;
    |                                      +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:340:38
    |
340 |             return "?".to_string() + operand;
    |                                      ^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
340 |             return "?".to_string() + &operand;
    |                                      +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:346:51
    |
346 |         let callee = self.generate_expression_str(expr.callee);
    |                           ----------------------- ^^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                           |
    |                           arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
346 |         let callee = self.generate_expression_str(&expr.callee);
    |                                                   +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:350:52
    |
350 |             args.push(self.generate_expression_str(arg));
    |                            ----------------------- ^^^ expected `&Expression`, found `Expression`
    |                            |
    |                            arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
350 |             args.push(self.generate_expression_str(&arg));
    |                                                    +

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:353:41
    |
353 |         let args_str = ", ".to_string().join(args);
    |                                         ^^^^ method not found in `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:354:25
    |
354 |         return callee + "(".to_string() + &args_str + ".to_string().to_string())";
    |                         ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
354 -         return callee + "(".to_string() + &args_str + ".to_string().to_string())";
354 +         return callee + "(" + &args_str + ".to_string().to_string())";
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:359:51
    |
359 |         let object = self.generate_expression_str(expr.object);
    |                           ----------------------- ^^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                           |
    |                           arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
359 |         let object = self.generate_expression_str(&expr.object);
    |                                                   +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:360:50
    |
360 |         let index = self.generate_expression_str(expr.index);
    |                          ----------------------- ^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                          |
    |                          arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
360 |         let index = self.generate_expression_str(&expr.index);
    |                                                  +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:361:25
    |
361 |         return object + "[".to_string() + &index + "]";
    |                         ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
361 -         return object + "[".to_string() + &index + "]";
361 +         return object + "[" + &index + "]";
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:366:51
    |
366 |         let object = self.generate_expression_str(expr.object);
    |                           ----------------------- ^^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                           |
    |                           arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
366 |         let object = self.generate_expression_str(&expr.object);
    |                                                   +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:367:25
    |
367 |         return object + ".".to_string() + &expr.attribute;
    |                         ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
367 -         return object + ".".to_string() + &expr.attribute;
367 +         return object + "." + &expr.attribute;
    |

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:374:56
    |
374 |             elements.push(self.generate_expression_str(elem));
    |                                ----------------------- ^^^^ expected `&Expression`, found `Expression`
    |                                |
    |                                arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
374 |             elements.push(self.generate_expression_str(&elem));
    |                                                        +

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:377:42
    |
377 |         let elems_str = ", ".to_string().join(elements);
    |                                          ^^^^ method not found in `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:385:56
    |
385 |             elements.push(self.generate_expression_str(elem));
    |                                ----------------------- ^^^^ expected `&Expression`, found `Expression`
    |                                |
    |                                arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
385 |             elements.push(self.generate_expression_str(&elem));
    |                                                        +

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:388:42
    |
388 |         let elems_str = ", ".to_string().join(elements);
    |                                          ^^^^ method not found in `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:396:56
    |
396 |             elements.push(self.generate_expression_str(elem));
    |                                ----------------------- ^^^^ expected `&Expression`, found `Expression`
    |                                |
    |                                arguments to this method are incorrect
    |
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
396 |             elements.push(self.generate_expression_str(&elem));
    |                                                        +

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:399:42
    |
399 |         let elems_str = ", ".to_string().join(elements);
    |                                          ^^^^ method not found in `String`

error[E0608]: cannot index into a value of type `(nodes::Expression, nodes::Expression)`
   --> codegen/rust_backend.rs:407:56
    |
407 |             let key = self.generate_expression_str(pair[0]);
    |                                                        ^^^ help: to access tuple element `0`, use: `.0`
    |
    = help: tuples are indexed with a dot and a literal index: `tuple.0`, `tuple.1`, etc.

error[E0608]: cannot index into a value of type `(nodes::Expression, nodes::Expression)`
   --> codegen/rust_backend.rs:408:58
    |
408 |             let value = self.generate_expression_str(pair[1]);
    |                                                          ^^^ help: to access tuple element `1`, use: `.1`
    |
    = help: tuples are indexed with a dot and a literal index: `tuple.0`, `tuple.1`, etc.

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:409:42
    |
409 |             pairs.push("(".to_string() + key + ", ".to_string() + &value + ".to_string())");
    |                                          ^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
409 |             pairs.push("(".to_string() + &key + ", ".to_string() + &value + ".to_string())");
    |                                          +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:409:48
    |
409 |             pairs.push("(".to_string() + key + ", ".to_string() + &value + ".to_string())");
    |                                                ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
409 -             pairs.push("(".to_string() + key + ", ".to_string() + &value + ".to_string())");
409 +             pairs.push("(".to_string() + key + ", " + &value + ".to_string())");
    |

error[E0599]: no method named `join` found for struct `String` in the current scope
   --> codegen/rust_backend.rs:412:42
    |
412 |         let pairs_str = ", ".to_string().join(pairs);
    |                                          ^^^^ method not found in `String`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:418:48
    |
418 |         let arg = self.generate_expression_str(expr.argument);
    |                        ----------------------- ^^^^^^^^^^^^^ expected `&Expression`, found `Box<Expression>`
    |                        |
    |                        arguments to this method are incorrect
    |
    = note: expected reference `&nodes::Expression`
                  found struct `Box<nodes::Expression>`
note: method defined here
   --> codegen/rust_backend.rs:266:12
    |
266 |     pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^^^^^^            -----------------
help: consider borrowing here
    |
418 |         let arg = self.generate_expression_str(&expr.argument);
    |                                                +

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:421:13
    |
420 |         match expr.type_name {
    |               -------------- this expression has type `String`
421 |             "int" => return "(".to_string() + &arg + " as i64)",
    |             ^^^^^ expected `String`, found `&str`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:422:13
    |
420 |         match expr.type_name {
    |               -------------- this expression has type `String`
421 |             "int" => return "(".to_string() + &arg + " as i64)",
422 |             "float" => return "(".to_string() + &arg + " as f64)",
    |             ^^^^^^^ expected `String`, found `&str`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:423:13
    |
420 |         match expr.type_name {
    |               -------------- this expression has type `String`
...
423 |             "str" => return "(".to_string() + &arg + ".to_string())",
    |             ^^^^^ expected `String`, found `&str`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:424:13
    |
420 |         match expr.type_name {
    |               -------------- this expression has type `String`
...
424 |             "bool" => return "(".to_string() + &arg + " as bool)",
    |             ^^^^^^ expected `String`, found `&str`

error[E0308]: mismatched types
   --> codegen/rust_backend.rs:425:31
    |
425 |             _ => return arg + " /* ".to_string() + &expr.type_name + " */",
    |                               ^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
425 -             _ => return arg + " /* ".to_string() + &expr.type_name + " */",
425 +             _ => return arg + " /* " + &expr.type_name + " */",
    |

error[E0308]: mismatched types
  --> ir/ir_builder.rs:18:23
   |
18 |                 name: "",
   |                       ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
18 |                 name: "".to_string(),
   |                         ++++++++++++

error[E0308]: mismatched types
  --> ir/ir_builder.rs:25:29
   |
25 |             current_struct: "",
   |                             ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
25 |             current_struct: "".to_string(),
   |                               ++++++++++++

error[E0615]: attempted to take value of method `stmt_type` on type `nodes::Statement`
  --> ir/ir_builder.rs:40:17
   |
40 |         if stmt.stmt_type == StmtType::StructDecl {
   |                 ^^^^^^^^^ method, not a field
   |
help: use parentheses to call the method
   |
40 |         if stmt.stmt_type() == StmtType::StructDecl {
   |                          ++

error[E0615]: attempted to take value of method `stmt_type` on type `nodes::Statement`
  --> ir/ir_builder.rs:43:22
   |
43 |         else if stmt.stmt_type == StmtType::FunctionDecl {
   |                      ^^^^^^^^^ method, not a field
   |
help: use parentheses to call the method
   |
43 |         else if stmt.stmt_type() == StmtType::FunctionDecl {
   |                               ++

error[E0615]: attempted to take value of method `stmt_type` on type `nodes::Statement`
  --> ir/ir_builder.rs:46:22
   |
46 |         else if stmt.stmt_type == StmtType::ImportStmt {
   |                      ^^^^^^^^^ method, not a field
   |
help: use parentheses to call the method
   |
46 |         else if stmt.stmt_type() == StmtType::ImportStmt {
   |                               ++

error[E0609]: no field `base` on type `nodes::Statement`
  --> ir/ir_builder.rs:53:95
   |
53 | ...   let mut ir_struct = IRStruct {base: IRNode {node_type: IRNodeType::Struct, line: stmt.base.line, column: stmt.base.column}, name: d...
   |                                                                                             ^^^^ unknown field

error[E0609]: no field `base` on type `nodes::Statement`
  --> ir/ir_builder.rs:53:119
   |
53 | ...   let mut ir_struct = IRStruct {base: IRNode {node_type: IRNodeType::Struct, line: stmt.base.line, column: stmt.base.column}, name: d...
   |                                                                                                                     ^^^^ unknown field

error[E0609]: no field `name` on type `nodes::Statement`
  --> ir/ir_builder.rs:53:144
   |
53 | ...ne: stmt.base.line, column: stmt.base.column}, name: decl.name, fields: vec![]};
   |                                                              ^^^^ unknown field

error[E0609]: no field `name` on type `nodes::Statement`
  --> ir/ir_builder.rs:54:36
   |
54 |         self.current_struct = decl.name;
   |                                    ^^^^ unknown field

error[E0609]: no field `body` on type `nodes::Statement`
  --> ir/ir_builder.rs:55:28
   |
55 |         for member in decl.body {
   |                            ^^^^ unknown field

error[E0599]: no variant or associated item named `FieldDecl` found for enum `nodes::StmtType` in the current scope
  --> ir/ir_builder.rs:56:46
   |
56 |             if member.stmt_type == StmtType::FieldDecl {
   |                                              ^^^^^^^^^ variant or associated item not found in `nodes::StmtType`
   |
  ::: ast/nodes.rs:27:1
   |
27 | pub enum StmtType {
   | ----------------- variant or associated item `FieldDecl` not found for this enum

error[E0308]: mismatched types
  --> ir/ir_builder.rs:57:222
   |
57 | ...e_to_rust(member.type_annotation), default_value: ""};
   |                                                      ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
57 |                 let field = IRField {base: IRNode {node_type: IRNodeType::Field, line: member.base.line, column: member.base.column}, name: member.name, type_name: gul_type_to_rust(member.type_annotation), default_value: "".to_string()};
   |                                                                                                                                                                                                                                ++++++++++++

error[E0609]: no field `name` on type `nodes::Statement`
  --> ir/ir_builder.rs:62:58
   |
62 |                 if !self.pending_impls.contains_key(decl.name) {
   |                                                          ^^^^ unknown field

error[E0609]: no field `name` on type `nodes::Statement`
  --> ir/ir_builder.rs:63:45
   |
63 |                     self.pending_impls[decl.name] = vec![];
   |                                             ^^^^ unknown field

error[E0609]: no field `name` on type `nodes::Statement`
  --> ir/ir_builder.rs:65:41
   |
65 |                 self.pending_impls[decl.name].push(ir_func);
   |                                         ^^^^ unknown field

error[E0308]: mismatched types
  --> ir/ir_builder.rs:69:31
   |
69 |         self.current_struct = "";
   |         -------------------   ^^ expected `String`, found `&str`
   |         |
   |         expected due to the type of this binding
   |
help: try using a conversion method
   |
69 |         self.current_struct = "".to_string();
   |                                 ++++++++++++

error[E0308]: mismatched types
  --> ir/ir_builder.rs:73:43
   |
73 |         let ir_func = self.build_function(stmt);
   |                            -------------- ^^^^ expected `FunctionDecl`, found `Statement`
   |                            |
   |                            arguments to this method are incorrect
   |
note: method defined here
  --> ir/ir_builder.rs:77:12
   |
77 |     pub fn build_function(&mut self, decl: FunctionDecl)  ->  IRFunction {
   |            ^^^^^^^^^^^^^^            ------------------

error[E0609]: no field `base` on type `nodes::FunctionDecl`
  --> ir/ir_builder.rs:78:97
   |
78 | ...   let mut ir_func = IRFunction {base: IRNode {node_type: IRNodeType::Function, line: decl.base.line, column: decl.base.column}, name:...
   |                                                                                               ^^^^ unknown field
   |
   = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0609]: no field `base` on type `nodes::FunctionDecl`
  --> ir/ir_builder.rs:78:121
   |
78 | ... IRNodeType::Function, line: decl.base.line, column: decl.base.column}, name: decl.name, params: vec![], return_type: gul_type_to_rust...
   |                                                              ^^^^ unknown field
   |
   = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0308]: mismatched types
  --> ir/ir_builder.rs:78:259
   |
78 | ..._type), body: vec![], is_method: false, receiver: ""};
   |                                                      ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
78 |         let mut ir_func = IRFunction {base: IRNode {node_type: IRNodeType::Function, line: decl.base.line, column: decl.base.column}, name: decl.name, params: vec![], return_type: gul_type_to_rust(decl.return_type), body: vec![], is_method: false, receiver: "".to_string()};
   |                                                                                                                                                                                                                                                                     ++++++++++++

error[E0609]: no field `base` on type `nodes::Parameter`
  --> ir/ir_builder.rs:85:105
   |
85 | ...   let ir_param = IRParameter {base: IRNode {node_type: IRNodeType::Parameter, line: param.base.line, column: param.base.column}, name...
   |                                                                                               ^^^^ unknown field
   |
   = note: available fields are: `name`, `type_annotation`, `ownership_mode`, `default_value`

error[E0609]: no field `base` on type `nodes::Parameter`
  --> ir/ir_builder.rs:85:130
   |
85 | ...NodeType::Parameter, line: param.base.line, column: param.base.column}, name: param.name, type_name: gul_type_to_rust(param.type_annot...
   |                                                              ^^^^ unknown field
   |
   = note: available fields are: `name`, `type_annotation`, `ownership_mode`, `default_value`

error[E0609]: no field `module_path` on type `nodes::Statement`
  --> ir/ir_builder.rs:93:26
   |
93 |         let parts = stmt.module_path;
   |                          ^^^^^^^^^^^ unknown field

error[E0369]: cannot add `&str` to `&str`
  --> ir/ir_builder.rs:97:29
   |
97 |                 path = path + "::";
   |                        ---- ^ ---- &str
   |                        |    |
   |                        |    `+` cannot be used to concatenate two `&str` strings
   |                        &str
   |
   = note: string concatenation requires an owned `String` on the left
help: create an owned `String` from a string reference
   |
97 |                 path = path.to_owned() + "::";
   |                            +++++++++++

error[E0369]: cannot add `_` to `&str`
  --> ir/ir_builder.rs:99:25
   |
99 |             path = path + part;
   |                    ---- ^ ---- _
   |                    |
   |                    &str

error[E0308]: mismatched types
    --> ir/ir_builder.rs:101:42
     |
 101 |         self.current_module.imports.push(path);
     |                                     ---- ^^^^ expected `String`, found `&str`
     |                                     |
     |                                     arguments to this method are incorrect
     |
note: method defined here
    --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:2563:12
     |
2563 |     pub fn push(&mut self, value: T) {
     |            ^^^^
help: try using a conversion method
     |
 101 |         self.current_module.imports.push(path.to_string());
     |                                              ++++++++++++

error[E0308]: mismatched types
  --> lexer/lexer.rs:41:87
   |
41 | ...                   l_tokens.push(Token{token_type: TokenType::Indent, value: "", line: 1, column: 1});
   |                                                                                 ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
41 |                             l_tokens.push(Token{token_type: TokenType::Indent, value: "".to_string(), line: 1, column: 1});
   |                                                                                         ++++++++++++

error[E0308]: mismatched types
  --> lexer/lexer.rs:47:91
   |
47 | ...                   l_tokens.push(Token{token_type: TokenType::Dedent, value: "", line: 1, column: 1});
   |                                                                                 ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
47 |                                 l_tokens.push(Token{token_type: TokenType::Dedent, value: "".to_string(), line: 1, column: 1});
   |                                                                                             ++++++++++++

error[E0308]: mismatched types
  --> lexer/lexer.rs:60:72
   |
60 |             l_tokens.push(Token{token_type: TokenType::Newline, value: "\n", line: 1, column: 1});
   |                                                                        ^^^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
60 |             l_tokens.push(Token{token_type: TokenType::Newline, value: "\n".to_string(), line: 1, column: 1});
   |                                                                            ++++++++++++

error[E0308]: mismatched types
  --> lexer/lexer.rs:77:83
   |
77 |                         l_tokens.push(Token{token_type: TokenType::Dedent, value: "", line: 1, column: 1});
   |                                                                                   ^^ expected `String`, found `&str`
   |
help: try using a conversion method
   |
77 |                         l_tokens.push(Token{token_type: TokenType::Dedent, value: "".to_string(), line: 1, column: 1});
   |                                                                                     ++++++++++++

error[E0308]: mismatched types
  --> lexer/lexer.rs:88:37
   |
88 |                     ident = ident + c;
   |                                     ^ expected `&str`, found `String`
   |
help: consider borrowing here
   |
88 |                     ident = ident + &c;
   |                                     +

error[E0308]: mismatched types
   --> lexer/lexer.rs:104:79
    |
104 |                     l_tokens.push(Token{token_type: TokenType::Dedent, value: "", line: 1, column: 1});
    |                                                                               ^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
104 |                     l_tokens.push(Token{token_type: TokenType::Dedent, value: "".to_string(), line: 1, column: 1});
    |                                                                                 ++++++++++++

error[E0308]: mismatched types
   --> lexer/lexer.rs:113:33
    |
113 |                     num = num + c;
    |                                 ^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
113 |                     num = num + &c;
    |                                 +

error[E0308]: mismatched types
   --> lexer/lexer.rs:125:79
    |
125 |                     l_tokens.push(Token{token_type: TokenType::Dedent, value: "", line: 1, column: 1});
    |                                                                               ^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
125 |                     l_tokens.push(Token{token_type: TokenType::Dedent, value: "".to_string(), line: 1, column: 1});
    |                                                                                 ++++++++++++

error[E0308]: mismatched types
   --> lexer/lexer.rs:146:67
    |
146 |         l_tokens.push(Token{token_type: TokenType::Dedent, value: "", line: 1, column: 1});
    |                                                                   ^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
146 |         l_tokens.push(Token{token_type: TokenType::Dedent, value: "".to_string(), line: 1, column: 1});
    |                                                                     ++++++++++++

error[E0308]: mismatched types
   --> lexer/lexer.rs:148:60
    |
148 |     l_tokens.push(Token{token_type: TokenType::Eof, value: "", line: 1, column: 1});
    |                                                            ^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
148 |     l_tokens.push(Token{token_type: TokenType::Eof, value: "".to_string(), line: 1, column: 1});
    |                                                              ++++++++++++

error[E0425]: cannot find function `to_string` in this scope
   --> parser/parser.rs:106:23
    |
106 |         println!("{}".to_string(), "Parse error: ".to_string() + message);
    |                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> parser/parser.rs:106:66
    |
106 |         println!("{}".to_string(), "Parse error: ".to_string() + message);
    |                                                                  ^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
106 |         println!("{}".to_string(), "Parse error: ".to_string() + &message);
    |                                                                  +

error[E0308]: mismatched types
   --> parser/parser.rs:138:124
    |
138 |             return Expression::UnaryOp(UnaryOpExpr{node: ASTNode{line: 1, column: 1}, operator: TokenType::Minus, operand: op});
    |                                                                                                                            ^^ expected `Box<Expression>`, found `Expression`
    |
    = note: expected struct `Box<nodes::Expression>`
                 found enum `nodes::Expression`
    = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
help: store this in the heap by calling `Box::new`
    |
138 |             return Expression::UnaryOp(UnaryOpExpr{node: ASTNode{line: 1, column: 1}, operator: TokenType::Minus, operand: Box::new(op)});
    |                                                                                                                            +++++++++  +

error[E0308]: mismatched types
   --> parser/parser.rs:140:90
    |
140 |         return Expression::Literal(LiteralExpr{node: ASTNode{line: 1, column: 1}, value: "None", value_type: TokenType::NoneLiteral});
    |                                                                                          ^^^^^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
140 |         return Expression::Literal(LiteralExpr{node: ASTNode{line: 1, column: 1}, value: "None".to_string(), value_type: TokenType::NoneLiteral});
    |                                                                                                ++++++++++++

error[E0599]: no variant or associated item named `NoneLiteral` found for enum `token::TokenType` in the current scope
   --> parser/parser.rs:140:121
    |
140 |         return Expression::Literal(LiteralExpr{node: ASTNode{line: 1, column: 1}, value: "None", value_type: TokenType::NoneLiteral});
    |                                                                                                                         ^^^^^^^^^^^ variant or associated item not found in `token::TokenType`
    |
   ::: lexer/token.rs:8:1
    |
  8 | pub enum TokenType {
    | ------------------ variant or associated item `NoneLiteral` not found for this enum

error[E0308]: mismatched types
   --> parser/parser.rs:147:95
    |
147 | ...node: ASTNode{line: 1, column: 1}, left: left, operator: token.token_type, right: right});
    |                                             ^^^^ expected `Box<Expression>`, found `Expression`
    |
    = note: expected struct `Box<nodes::Expression>`
                 found enum `nodes::Expression`
    = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
help: store this in the heap by calling `Box::new`
    |
147 |             return Expression::BinaryOp(BinaryOpExpr{node: ASTNode{line: 1, column: 1}, left: Box::new(left), operator: token.token_type, right: right});
    |                                                                                               +++++++++    +

error[E0308]: mismatched types
   --> parser/parser.rs:147:136
    |
147 | ...left, operator: token.token_type, right: right});
    |                                             ^^^^^ expected `Box<Expression>`, found `Expression`
    |
    = note: expected struct `Box<nodes::Expression>`
                 found enum `nodes::Expression`
    = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
help: store this in the heap by calling `Box::new`
    |
147 |             return Expression::BinaryOp(BinaryOpExpr{node: ASTNode{line: 1, column: 1}, left: left, operator: token.token_type, right: Box::new(right)});
    |                                                                                                                                        +++++++++     +

error[E0308]: mismatched types
   --> parser/parser.rs:158:89
    |
158 |             return Expression::Call(CallExpr{node: ASTNode{line: 1, column: 1}, callee: left, arguments: args});
    |                                                                                         ^^^^ expected `Box<Expression>`, found `Expression`
    |
    = note: expected struct `Box<nodes::Expression>`
                 found enum `nodes::Expression`
    = note: for more on the distinction between the stack and the heap, read https://doc.rust-lang.org/book/ch15-01-box.html, https://doc.rust-lang.org/rust-by-example/std/box.html, and https://doc.rust-lang.org/std/boxed/index.html
help: store this in the heap by calling `Box::new`
    |
158 |             return Expression::Call(CallExpr{node: ASTNode{line: 1, column: 1}, callee: Box::new(left), arguments: args});
    |                                                                                         +++++++++    +

error[E0063]: missing field `keyword_args` in initializer of `nodes::CallExpr`
   --> parser/parser.rs:158:37
    |
158 |             return Expression::Call(CallExpr{node: ASTNode{line: 1, column: 1}, callee: left, arguments: args});
    |                                     ^^^^^^^^ missing `keyword_args`

error[E0560]: struct `nodes::LetStmt` has no field named `is_var`
   --> parser/parser.rs:170:106
    |
170 |             return Statement::LetDecl(LetStmt{node: ASTNode{line: 1, column: 1}, name: name, value: val, is_var: false});
    |                                                                                                          ^^^^^^ `nodes::LetStmt` does not have this field
    |
    = note: available fields are: `type_annotation`

error[E0308]: mismatched types
   --> parser/parser.rs:184:83
    |
184 |                 if self.tokens[self.current_pos].token_type == TokenType::Comma { self.advance() }
    |                 ------------------------------------------------------------------^^^^^^^^^^^^^^--
    |                 |                                                                 |
    |                 |                                                                 expected `()`, found `Token`
    |                 expected this to be `()`
    |
help: consider using a semicolon here
    |
184 |                 if self.tokens[self.current_pos].token_type == TokenType::Comma { self.advance(); }
    |                                                                                                 +
help: consider using a semicolon here
    |
184 |                 if self.tokens[self.current_pos].token_type == TokenType::Comma { self.advance() };
    |                                                                                                   +

error[E0034]: multiple applicable items in scope
   --> parser/parser.rs:192:32
    |
192 |                 body.push(self.parse_statement());
    |                                ^^^^^^^^^^^^^^^ multiple `parse_statement` found
    |
note: candidate #1 is defined in an impl for the type `Parser`
   --> parser/parser.rs:163:5
    |
163 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl for the type `Parser`
   --> parser/parser.rs:239:5
    |
239 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0308]: mismatched types
   --> parser/parser.rs:193:85
    |
193 |                 if self.tokens[self.current_pos].token_type == TokenType::Newline { self.advance() }
    |                 --------------------------------------------------------------------^^^^^^^^^^^^^^--
    |                 |                                                                   |
    |                 |                                                                   expected `()`, found `Token`
    |                 expected this to be `()`
    |
help: consider using a semicolon here
    |
193 |                 if self.tokens[self.current_pos].token_type == TokenType::Newline { self.advance(); }
    |                                                                                                   +
help: consider using a semicolon here
    |
193 |                 if self.tokens[self.current_pos].token_type == TokenType::Newline { self.advance() };
    |                                                                                                     +

error[E0560]: struct `nodes::FunctionDecl` has no field named `params`
   --> parser/parser.rs:196:104
    |
196 | ...STNode{line: 1, column: 1}, name: name, params: vec![], body: body, return_type: "Any"});
    |                                            ^^^^^^ `nodes::FunctionDecl` does not have this field
    |
    = note: available fields are: `is_async`, `parameters`, `decorators`

error[E0425]: cannot find function `to_string` in this scope
   --> parser/parser.rs:206:23
    |
206 |         println!("{}".to_string(), "    Parser: parse_program start".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> parser/parser.rs:208:27
    |
208 |             println!("{}".to_string(), "    Parser POS: ".to_string() + &format!("{}".to_string(), self.current_pos));
    |                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> parser/parser.rs:208:87
    |
208 |             println!("{}".to_string(), "    Parser POS: ".to_string() + &format!("{}".to_string(), self.current_pos));
    |                                                                                       ^^^^^^^^^ not found in this scope

error[E0034]: multiple applicable items in scope
   --> parser/parser.rs:214:38
    |
214 |                 statements.push(self.parse_statement());
    |                                      ^^^^^^^^^^^^^^^ multiple `parse_statement` found
    |
note: candidate #1 is defined in an impl for the type `Parser`
   --> parser/parser.rs:163:5
    |
163 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl for the type `Parser`
   --> parser/parser.rs:239:5
    |
239 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:298:26
    |
298 |         let value = self.parse_expression();
    |                          ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
298 |         let value = self.parse_expression(/* Precedence */);
    |                                           ++++++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:323:26
    |
323 |         let value = self.parse_expression();
    |                          ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
323 |         let value = self.parse_expression(/* Precedence */);
    |                                           ++++++++++++++++

error[E0308]: mismatched types
   --> parser/parser.rs:410:28
    |
410 |             default_value: None, // TODO: parse default values
    |                            ^^^^ expected `Expression`, found `Option<_>`
    |
    = note: expected enum `nodes::Expression`
               found enum `Option<_>`

error[E0034]: multiple applicable items in scope
   --> parser/parser.rs:424:34
    |
424 |             statements.push(self.parse_statement());
    |                                  ^^^^^^^^^^^^^^^ multiple `parse_statement` found
    |
note: candidate #1 is defined in an impl for the type `Parser`
   --> parser/parser.rs:163:5
    |
163 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
note: candidate #2 is defined in an impl for the type `Parser`
   --> parser/parser.rs:239:5
    |
239 |     pub fn parse_statement(&mut self)  ->  Statement {
    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:435:30
    |
435 |         let condition = self.parse_expression();
    |                              ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
435 |         let condition = self.parse_expression(/* Precedence */);
    |                                               ++++++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:448:39
    |
448 |             let elif_condition = self.parse_expression();
    |                                       ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
448 |             let elif_condition = self.parse_expression(/* Precedence */);
    |                                                        ++++++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:484:30
    |
484 |         let condition = self.parse_expression();
    |                              ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
484 |         let condition = self.parse_expression(/* Precedence */);
    |                                               ++++++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:503:29
    |
503 |         let iterable = self.parse_expression();
    |                             ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
503 |         let iterable = self.parse_expression(/* Precedence */);
    |                                              ++++++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:525:26
    |
525 |             value = self.parse_expression();
    |                          ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
525 |             value = self.parse_expression(/* Precedence */);
    |                                           ++++++++++++++++

error[E0308]: mismatched types
   --> parser/parser.rs:525:21
    |
521 |         let mut value = None;
    |                         ---- expected due to this value
...
525 |             value = self.parse_expression();
    |                     ^^^^^^^^^^^^^^^^^^^^^^^ expected `Option<_>`, found `Expression`
    |
    = note: expected enum `Option<_>`
               found enum `nodes::Expression`
help: try wrapping the expression in `Some`
    |
525 |             value = Some(self.parse_expression());
    |                     +++++                       +

error[E0308]: mismatched types
   --> parser/parser.rs:530:20
    |
530 |             value: value,
    |                    ^^^^^ expected `Expression`, found `Option<_>`
    |
    = note: expected enum `nodes::Expression`
               found enum `Option<_>`
help: consider using `Option::expect` to unwrap the `Option<_>` value, panicking if the value is an `Option::None`
    |
530 |             value: value.expect("REASON"),
    |                         +++++++++++++++++

error[E0308]: mismatched types
   --> parser/parser.rs:566:26
    |
566 |             import_type: "single",
    |                          ^^^^^^^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
566 |             import_type: "single".to_string(),
    |                                  ++++++++++++

error[E0061]: this method takes 1 argument but 0 arguments were supplied
   --> parser/parser.rs:575:25
    |
575 |         let expr = self.parse_expression();
    |                         ^^^^^^^^^^^^^^^^-- argument #1 of type `Precedence` is missing
    |
note: method defined here
   --> parser/parser.rs:110:12
    |
110 |     pub fn parse_expression(&mut self, min_precedence: Precedence)  ->  Expression {
    |            ^^^^^^^^^^^^^^^^            --------------------------
help: provide the argument
    |
575 |         let expr = self.parse_expression(/* Precedence */);
    |                                          ++++++++++++++++

error[E0308]: mismatched types
  --> semantic/analyzer.rs:26:51
   |
26 |     return Scope{symbols: HashMap::new(), parent: None};
   |                                                   ^^^^ expected `Scope`, found `Option<_>`
   |
   = note: expected struct `analyzer::Scope`
                found enum `Option<_>`

error: reached the recursion limit finding the struct tail for `analyzer::Scope`
  --> semantic/analyzer.rs:20:1
   |
20 | pub struct Scope {
   | ^^^^^^^^^^^^^^^^
   |
   = help: consider increasing the recursion limit by adding a `#![recursion_limit = "256"]`

error[E0308]: mismatched types
  --> semantic/analyzer.rs:95:12
   |
95 |         if self.current_scope.parent {
   |            ^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `Scope`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:102:74
    |
102 | ...   let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(),...
    |                                                                        ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> semantic/analyzer.rs:102:95
    |
102 | ...ing() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                               ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
102 -         let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
102 +         let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":" + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:102:128
    |
102 | ...tring(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> semantic/analyzer.rs:102:151
    |
102 | ...() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                               ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
102 -         let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
102 +         let error_msg = "Semantic error at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": " + &message;
    |

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:104:23
    |
104 |         println!("{}".to_string(), error_msg);
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:109:66
    |
109 | ...   let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column)...
    |                                                                ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> semantic/analyzer.rs:109:87
    |
109 | ...   let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column)...
    |                                                                                     ^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
109 -         let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
109 +         let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":" + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:109:120
    |
109 | ...tring(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                                      ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> semantic/analyzer.rs:109:143
    |
109 | ...() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
    |                                               ^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: try removing the method call
    |
109 -         let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": ".to_string() + &message;
109 +         let warn_msg = "Warning at ".to_string() + &format!("{}".to_string(), line) + ":".to_string() + &&format!("{}".to_string(), column) + ": " + &message;
    |

error[E0615]: attempted to take value of method `stmt_type` on type `nodes::Statement`
   --> semantic/analyzer.rs:119:23
    |
119 |         let st = stmt.stmt_type;
    |                       ^^^^^^^^^ method, not a field
    |
help: use parentheses to call the method
    |
119 |         let st = stmt.stmt_type();
    |                                ++

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::LetStmt`
   --> semantic/analyzer.rs:120:60
    |
120 |         if st == StmtType::LetDecl { self.analyze_let_stmt((stmt as LetStmt)) }
    |                                                            ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::VarStmt`
   --> semantic/analyzer.rs:121:65
    |
121 |         else if st == StmtType::VarDecl { self.analyze_var_stmt((stmt as VarStmt)) }
    |                                                                 ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::FunctionDecl`
   --> semantic/analyzer.rs:122:75
    |
122 |         else if st == StmtType::FunctionDecl { self.analyze_function_decl((stmt as FunctionDecl)) }
    |                                                                           ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::IfStmt`
   --> semantic/analyzer.rs:123:63
    |
123 |         else if st == StmtType::IfStmt { self.analyze_if_stmt((stmt as IfStmt)) }
    |                                                               ^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::WhileStmt`
   --> semantic/analyzer.rs:124:69
    |
124 |         else if st == StmtType::WhileStmt { self.analyze_while_stmt((stmt as WhileStmt)) }
    |                                                                     ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::ForStmt`
   --> semantic/analyzer.rs:125:65
    |
125 |         else if st == StmtType::ForStmt { self.analyze_for_stmt((stmt as ForStmt)) }
    |                                                                 ^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::ReturnStmt`
   --> semantic/analyzer.rs:126:71
    |
126 |         else if st == StmtType::ReturnStmt { self.analyze_return_stmt((stmt as ReturnStmt)) }
    |                                                                       ^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::AssignmentStmt`
   --> semantic/analyzer.rs:127:74
    |
127 |         else if st == StmtType::AssignmentStmt { self.analyze_assignment((stmt as AssignmentStmt)) }
    |                                                                          ^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::ExpressionStmt`
   --> semantic/analyzer.rs:128:79
    |
128 |         else if st == StmtType::ExpressionStmt { self.analyze_expression_stmt((stmt as ExpressionStmt)) }
    |                                                                               ^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Statement` as `nodes::ImportStmt`
   --> semantic/analyzer.rs:129:66
    |
129 |         else if st == StmtType::ImportStmt { self.analyze_import((stmt as ImportStmt)) }
    |                                                                  ^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:137:64
    |
137 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::LetStmt`
   --> semantic/analyzer.rs:137:94
    |
137 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0609]: no field `base` on type `nodes::LetStmt`
   --> semantic/analyzer.rs:137:115
    |
137 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                                                   ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:144:12
    |
144 |         if stmt.type_annotation && value_type {
    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:144:36
    |
144 |         if stmt.type_annotation && value_type {
    |                                    ^^^^^^^^^^ expected `bool`, found `String`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:146:73
    |
146 |                 self.error(format!("Type mismatch: expected {}, got {}".to_string(), stmt.type_annotation, value_type),
    |                                                                         ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::LetStmt`
   --> semantic/analyzer.rs:147:30
    |
147 |                         stmt.base.node.line, stmt.base.node.column);
    |                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0609]: no field `base` on type `nodes::LetStmt`
   --> semantic/analyzer.rs:147:51
    |
147 |                         stmt.base.node.line, stmt.base.node.column);
    |                                                   ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:154:19
    |
154 |             type: stmt.type_annotation || value_type,
    |                   ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:154:43
    |
154 |             type: stmt.type_annotation || value_type,
    |                                           ^^^^^^^^^^ expected `bool`, found `String`

error[E0609]: no field `base` on type `nodes::LetStmt`
   --> semantic/analyzer.rs:157:24
    |
157 |             line: stmt.base.node.line,
    |                        ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0609]: no field `base` on type `nodes::LetStmt`
   --> semantic/analyzer.rs:158:26
    |
158 |             column: stmt.base.node.column,
    |                          ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:166:64
    |
166 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::VarStmt`
   --> semantic/analyzer.rs:166:94
    |
166 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0609]: no field `base` on type `nodes::VarStmt`
   --> semantic/analyzer.rs:166:115
    |
166 |             self.error(format!("Variable '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                                                   ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:171:12
    |
171 |         if stmt.type_annotation && value_type {
    |            ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:171:36
    |
171 |         if stmt.type_annotation && value_type {
    |                                    ^^^^^^^^^^ expected `bool`, found `String`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:173:73
    |
173 |                 self.error(format!("Type mismatch: expected {}, got {}".to_string(), stmt.type_annotation, value_type),
    |                                                                         ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::VarStmt`
   --> semantic/analyzer.rs:174:30
    |
174 |                         stmt.base.node.line, stmt.base.node.column);
    |                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0609]: no field `base` on type `nodes::VarStmt`
   --> semantic/analyzer.rs:174:51
    |
174 |                         stmt.base.node.line, stmt.base.node.column);
    |                                                   ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:180:19
    |
180 |             type: stmt.type_annotation || value_type,
    |                   ^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:180:43
    |
180 |             type: stmt.type_annotation || value_type,
    |                                           ^^^^^^^^^^ expected `bool`, found `String`

error[E0609]: no field `base` on type `nodes::VarStmt`
   --> semantic/analyzer.rs:183:24
    |
183 |             line: stmt.base.node.line,
    |                        ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0609]: no field `base` on type `nodes::VarStmt`
   --> semantic/analyzer.rs:184:26
    |
184 |             column: stmt.base.node.column,
    |                          ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `type_annotation`, `value`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:192:64
    |
192 |             self.error(format!("Function '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::FunctionDecl`
   --> semantic/analyzer.rs:192:94
    |
192 |             self.error(format!("Function '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0609]: no field `base` on type `nodes::FunctionDecl`
   --> semantic/analyzer.rs:192:115
    |
192 |             self.error(format!("Function '{}' already defined".to_string(), stmt.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                                                   ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0308]: mismatched types
   --> semantic/analyzer.rs:198:19
    |
198 |             type: stmt.return_type || "void",
    |                   ^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:198:39
    |
198 |             type: stmt.return_type || "void",
    |                                       ^^^^^^ expected `bool`, found `&str`

error[E0609]: no field `base` on type `nodes::FunctionDecl`
   --> semantic/analyzer.rs:201:24
    |
201 |             line: stmt.base.node.line,
    |                        ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0609]: no field `base` on type `nodes::FunctionDecl`
   --> semantic/analyzer.rs:202:26
    |
202 |             column: stmt.base.node.column,
    |                          ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0308]: mismatched types
   --> semantic/analyzer.rs:213:23
    |
213 |                 type: param.type_annotation || "any",
    |                       ^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `String`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:213:48
    |
213 |                 type: param.type_annotation || "any",
    |                                                ^^^^^ expected `bool`, found `&str`

error[E0609]: no field `base` on type `nodes::FunctionDecl`
   --> semantic/analyzer.rs:216:28
    |
216 |                 line: stmt.base.node.line,
    |                            ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0609]: no field `base` on type `nodes::FunctionDecl`
   --> semantic/analyzer.rs:217:30
    |
217 |                 column: stmt.base.node.column,
    |                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`, `is_async`, `parameters`, `return_type` ... and 2 others

error[E0308]: mismatched types
   --> semantic/analyzer.rs:235:12
    |
235 |         if cond_type && cond_type != "bool".to_string() {
    |            ^^^^^^^^^ expected `bool`, found `String`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:236:66
    |
236 |             self.warn(format!("Condition should be bool, got {}".to_string(), cond_type), stmt.base.node.line, stmt.base.node.column);
    |                                                                  ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::IfStmt`
   --> semantic/analyzer.rs:236:96
    |
236 |             self.warn(format!("Condition should be bool, got {}".to_string(), cond_type), stmt.base.node.line, stmt.base.node.column);
    |                                                                                                ^^^^ unknown field
    |
    = note: available fields are: `node`, `condition`, `then_body`, `elif_clauses`, `else_body`

error[E0609]: no field `base` on type `nodes::IfStmt`
   --> semantic/analyzer.rs:236:117
    |
236 |             self.warn(format!("Condition should be bool, got {}".to_string(), cond_type), stmt.base.node.line, stmt.base.node.column);
    |                                                                                                                     ^^^^ unknown field
    |
    = note: available fields are: `node`, `condition`, `then_body`, `elif_clauses`, `else_body`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:257:12
    |
257 |         if stmt.else_body {
    |            ^^^^^^^^^^^^^^ expected `bool`, found `Vec<Statement>`
    |
    = note: expected type `bool`
             found struct `Vec<nodes::Statement>`

error[E0609]: no field `base` on type `nodes::ForStmt`
   --> semantic/analyzer.rs:289:24
    |
289 |             line: stmt.base.node.line,
    |                        ^^^^ unknown field
    |
    = note: available fields are: `node`, `variable`, `iterable`, `body`

error[E0609]: no field `base` on type `nodes::ForStmt`
   --> semantic/analyzer.rs:290:26
    |
290 |             column: stmt.base.node.column,
    |                          ^^^^ unknown field
    |
    = note: available fields are: `node`, `variable`, `iterable`, `body`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:303:12
    |
303 |         if stmt.value {
    |            ^^^^^^^^^^ expected `bool`, found `Expression`

error[E0609]: no field `expr_type` on type `nodes::Expression`
   --> semantic/analyzer.rs:311:24
    |
311 |         if stmt.target.expr_type == ExprType::Identifier {
    |                        ^^^^^^^^^ unknown field

error[E0600]: cannot apply unary operator `!` to type `Symbol`
   --> semantic/analyzer.rs:315:16
    |
315 |             if ! symbol {
    |                ^^^^^^^^ cannot apply unary operator `!`
    |
note: an implementation of `Not` might be missing for `Symbol`
   --> semantic/analyzer.rs:10:1
    |
 10 | pub struct Symbol {
    | ^^^^^^^^^^^^^^^^^ must implement `Not`
note: the trait `Not` must be implemented
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/bit.rs:35:1
    |
 35 | pub const trait Not {
    | ^^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:316:62
    |
316 |                 self.error(format!("Undefined variable '{}'".to_string(), ident.name), stmt.base.node.line, stmt.base.node.column);
    |                                                              ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::AssignmentStmt`
   --> semantic/analyzer.rs:316:93
    |
316 |                 self.error(format!("Undefined variable '{}'".to_string(), ident.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                             ^^^^ unknown field
    |
    = note: available fields are: `node`, `target`, `operator`, `value`

error[E0609]: no field `base` on type `nodes::AssignmentStmt`
   --> semantic/analyzer.rs:316:114
    |
316 |                 self.error(format!("Undefined variable '{}'".to_string(), ident.name), stmt.base.node.line, stmt.base.node.column);
    |                                                                                                                  ^^^^ unknown field
    |
    = note: available fields are: `node`, `target`, `operator`, `value`

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:319:79
    |
319 |                 self.error(format!("Cannot assign to immutable variable '{}'".to_string(), ident.name),
    |                                                                               ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::AssignmentStmt`
   --> semantic/analyzer.rs:320:30
    |
320 |                         stmt.base.node.line, stmt.base.node.column);
    |                              ^^^^ unknown field
    |
    = note: available fields are: `node`, `target`, `operator`, `value`

error[E0609]: no field `base` on type `nodes::AssignmentStmt`
   --> semantic/analyzer.rs:320:51
    |
320 |                         stmt.base.node.line, stmt.base.node.column);
    |                                                   ^^^^ unknown field
    |
    = note: available fields are: `node`, `target`, `operator`, `value`

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::IdentifierExpr`
   --> semantic/analyzer.rs:312:25
    |
312 |             let ident = (stmt.target as IdentifierExpr);
    |                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0609]: no field `expr_type` on type `nodes::Expression`
   --> semantic/analyzer.rs:346:23
    |
346 |         let et = expr.expr_type;
    |                       ^^^^^^^^^ unknown field

error[E0599]: no method named `analyze_list_literal` found for mutable reference `&mut SemanticAnalyzer` in the current scope
   --> semantic/analyzer.rs:357:59
    |
357 |         else if et == ExprType::ListLiteral { return self.analyze_list_literal((expr as ListLiteralExpr)) }
    |                                                           ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `analyze_let_stmt` with a similar name
    |
357 -         else if et == ExprType::ListLiteral { return self.analyze_list_literal((expr as ListLiteralExpr)) }
357 +         else if et == ExprType::ListLiteral { return self.analyze_let_stmt((expr as ListLiteralExpr)) }
    |

error[E0599]: no method named `analyze_tuple_literal` found for mutable reference `&mut SemanticAnalyzer` in the current scope
   --> semantic/analyzer.rs:358:60
    |
358 |         else if et == ExprType::TupleLiteral { return self.analyze_tuple_literal((expr as TupleLiteralExpr)) }
    |                                                            ^^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `analyze_program` with a similar name
    |
358 -         else if et == ExprType::TupleLiteral { return self.analyze_tuple_literal((expr as TupleLiteralExpr)) }
358 +         else if et == ExprType::TupleLiteral { return self.analyze_program((expr as TupleLiteralExpr)) }
    |

error[E0599]: no method named `analyze_set_literal` found for mutable reference `&mut SemanticAnalyzer` in the current scope
   --> semantic/analyzer.rs:359:58
    |
359 |         else if et == ExprType::SetLiteral { return self.analyze_set_literal((expr as SetLiteralExpr)) }
    |                                                          ^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `analyze_let_stmt` with a similar name
    |
359 -         else if et == ExprType::SetLiteral { return self.analyze_set_literal((expr as SetLiteralExpr)) }
359 +         else if et == ExprType::SetLiteral { return self.analyze_let_stmt((expr as SetLiteralExpr)) }
    |

error[E0599]: no method named `analyze_dict_literal` found for mutable reference `&mut SemanticAnalyzer` in the current scope
   --> semantic/analyzer.rs:360:59
    |
360 |         else if et == ExprType::DictLiteral { return self.analyze_dict_literal((expr as DictLiteralExpr)) }
    |                                                           ^^^^^^^^^^^^^^^^^^^^
    |
help: there is a method `analyze_call` with a similar name
    |
360 -         else if et == ExprType::DictLiteral { return self.analyze_dict_literal((expr as DictLiteralExpr)) }
360 +         else if et == ExprType::DictLiteral { return self.analyze_call((expr as DictLiteralExpr)) }
    |

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::IdentifierExpr`
   --> semantic/analyzer.rs:351:77
    |
351 |         else if et == ExprType::Identifier { return self.analyze_identifier((expr as IdentifierExpr)) }
    |                                                                             ^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::BinaryOpExpr`
   --> semantic/analyzer.rs:352:74
    |
352 |         else if et == ExprType::BinaryOp { return self.analyze_binary_op((expr as BinaryOpExpr)) }
    |                                                                          ^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::UnaryOpExpr`
   --> semantic/analyzer.rs:353:72
    |
353 |         else if et == ExprType::UnaryOp { return self.analyze_unary_op((expr as UnaryOpExpr)) }
    |                                                                        ^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::CallExpr`
   --> semantic/analyzer.rs:354:65
    |
354 |         else if et == ExprType::Call { return self.analyze_call((expr as CallExpr)) }
    |                                                                 ^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::IndexExpr`
   --> semantic/analyzer.rs:355:67
    |
355 |         else if et == ExprType::Index { return self.analyze_index((expr as IndexExpr)) }
    |                                                                   ^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::AttributeExpr`
   --> semantic/analyzer.rs:356:75
    |
356 |         else if et == ExprType::Attribute { return self.analyze_attribute((expr as AttributeExpr)) }
    |                                                                           ^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0605]: non-primitive cast: `nodes::Expression` as `nodes::TypeConstructorExpr`
   --> semantic/analyzer.rs:361:88
    |
361 |         else if et == ExprType::TypeConstructor { return self.analyze_type_constructor((expr as TypeConstructorExpr)) }
    |                                                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ an `as` expression can only be used to convert between primitive types or to coerce to a specific trait object

error[E0600]: cannot apply unary operator `!` to type `Symbol`
   --> semantic/analyzer.rs:369:12
    |
369 |         if ! symbol {
    |            ^^^^^^^^ cannot apply unary operator `!`
    |
note: an implementation of `Not` might be missing for `Symbol`
   --> semantic/analyzer.rs:10:1
    |
 10 | pub struct Symbol {
    | ^^^^^^^^^^^^^^^^^ must implement `Not`
note: the trait `Not` must be implemented
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/core/src/ops/bit.rs:35:1
    |
 35 | pub const trait Not {
    | ^^^^^^^^^^^^^^^^^^^

error[E0425]: cannot find function `to_string` in this scope
   --> semantic/analyzer.rs:370:58
    |
370 |             self.error(format!("Undefined variable '{}'".to_string(), expr.name), expr.base.node.line, expr.base.node.column);
    |                                                          ^^^^^^^^^ not found in this scope

error[E0609]: no field `base` on type `nodes::IdentifierExpr`
   --> semantic/analyzer.rs:370:88
    |
370 |             self.error(format!("Undefined variable '{}'".to_string(), expr.name), expr.base.node.line, expr.base.node.column);
    |                                                                                        ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`

error[E0609]: no field `base` on type `nodes::IdentifierExpr`
   --> semantic/analyzer.rs:370:109
    |
370 |             self.error(format!("Undefined variable '{}'".to_string(), expr.name), expr.base.node.line, expr.base.node.column);
    |                                                                                                             ^^^^ unknown field
    |
    = note: available fields are: `node`, `name`

error[E0308]: mismatched types
   --> semantic/analyzer.rs:379:49
    |
379 |         let left_type = self.analyze_expression(expr.left);
    |                              ------------------ ^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                              |
    |                              arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
379 |         let left_type = self.analyze_expression(*expr.left);
    |                                                 +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:380:50
    |
380 |         let right_type = self.analyze_expression(expr.right);
    |                               ------------------ ^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                               |
    |                               arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
380 |         let right_type = self.analyze_expression(*expr.right);
    |                                                  +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:421:52
    |
421 |         let operand_type = self.analyze_expression(expr.operand);
    |                                 ------------------ ^^^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                                 |
    |                                 arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
421 |         let operand_type = self.analyze_expression(*expr.operand);
    |                                                    +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:437:51
    |
437 |         let callee_type = self.analyze_expression(expr.callee);
    |                                ------------------ ^^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                                |
    |                                arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
437 |         let callee_type = self.analyze_expression(*expr.callee);
    |                                                   +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:450:51
    |
450 |         let object_type = self.analyze_expression(expr.object);
    |                                ------------------ ^^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                                |
    |                                arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
450 |         let object_type = self.analyze_expression(*expr.object);
    |                                                   +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:451:50
    |
451 |         let index_type = self.analyze_expression(expr.index);
    |                               ------------------ ^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                               |
    |                               arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
451 |         let index_type = self.analyze_expression(*expr.index);
    |                                                  +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:459:51
    |
459 |         let object_type = self.analyze_expression(expr.object);
    |                                ------------------ ^^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |                                |
    |                                arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
459 |         let object_type = self.analyze_expression(*expr.object);
    |                                                   +

error[E0308]: mismatched types
   --> semantic/analyzer.rs:467:33
    |
467 |         self.analyze_expression(expr.argument);
    |              ------------------ ^^^^^^^^^^^^^ expected `Expression`, found `Box<Expression>`
    |              |
    |              arguments to this method are incorrect
    |
    = note: expected enum `nodes::Expression`
             found struct `Box<nodes::Expression>`
note: method defined here
   --> semantic/analyzer.rs:344:12
    |
344 |     pub fn analyze_expression(&mut self, expr: Expression)  ->  String {
    |            ^^^^^^^^^^^^^^^^^^            ----------------
help: consider unboxing the value
    |
467 |         self.analyze_expression(*expr.argument);
    |                                 +

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:107:23
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:107:87
    |
107 |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:108:16
    |
101 | pub fn compiler_read_source_file(compiler: Compiler)  ->  String {
    |                                                           ------ expected `String` because of return type
...
108 |         return "";
    |                ^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
108 |         return "".to_string();
    |                  ++++++++++++

error[E0317]: `if` may be missing an `else` clause
   --> main.rs:106:10
    |
106 |       else if false {
    |  __________^
107 | |         println!("{}".to_string(), "Error reading file: ".to_string() + &format!("{}".to_string(), e));
108 | |         return "";
109 | |
110 | |     }
    | |_____^ expected `String`, found `()`
    |
    = note: `if` expressions without `else` evaluate to `()`
    = help: consider adding an `else` block that evaluates to the expected type

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:117:27
    |
117 |             println!("{}".to_string(), "Generated code written to ".to_string() + compiler.config.output_file);
    |                           ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:117:83
    |
117 |             println!("{}".to_string(), "Generated code written to ".to_string() + compiler.config.output_file);
    |                                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
117 |             println!("{}".to_string(), "Generated code written to ".to_string() + &compiler.config.output_file);
    |                                                                                   +

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:121:23
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:121:87
    |
121 |         println!("{}".to_string(), "Error writing file: ".to_string() + &format!("{}".to_string(), e));
    |                                                                                       ^^^^^^^^^ not found in this scope

error[E0600]: cannot apply unary operator `!` to type `String`
   --> main.rs:136:8
    |
136 |     if ! source {
    |        ^^^^^^^^ cannot apply unary operator `!`
    |
note: the foreign item type `String` doesn't implement `Not`
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/string.rs:360:1
    |
360 | pub struct String {
    | ^^^^^^^^^^^^^^^^^ not implement `Not`

error[E0308]: mismatched types
   --> main.rs:138:46
    |
138 |         return compiler_create_result(false, "", errors, warnings);
    |                ----------------------        ^^ expected `String`, found `&str`
    |                |
    |                arguments to this function are incorrect
    |
note: function defined here
   --> main.rs:125:8
    |
125 | pub fn compiler_create_result(success: bool, code: String, errors: Vec<String>, warnings: Vec<String>)  ->  CompileResult {
    |        ^^^^^^^^^^^^^^^^^^^^^^                ------------
help: try using a conversion method
    |
138 |         return compiler_create_result(false, "".to_string(), errors, warnings);
    |                                                ++++++++++++

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:141:19
    |
141 |     println!("{}".to_string(), "  [1/4] Lexing...".to_string());
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:143:19
    |
143 |     println!("{}".to_string(), "    Lexed ".to_string() + &format!("{}".to_string(), (tokens).len()) + " tokens");
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:143:73
    |
143 |     println!("{}".to_string(), "    Lexed ".to_string() + &format!("{}".to_string(), (tokens).len()) + " tokens");
    |                                                                         ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:145:19
    |
145 |     println!("{}".to_string(), "  [2/4] Parsing...".to_string());
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `parse_with_tokens` in this scope
   --> main.rs:146:15
    |
146 |     let ast = parse_with_tokens(tokens);
    |               ^^^^^^^^^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:153:27
    |
153 |             println!("{}".to_string(), "  [3/4] Semantic analysis...".to_string());
    |                           ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:160:50
    |
160 |             return compiler_create_result(false, "", errors, warnings);
    |                    ----------------------        ^^ expected `String`, found `&str`
    |                    |
    |                    arguments to this function are incorrect
    |
note: function defined here
   --> main.rs:125:8
    |
125 | pub fn compiler_create_result(success: bool, code: String, errors: Vec<String>, warnings: Vec<String>)  ->  CompileResult {
    |        ^^^^^^^^^^^^^^^^^^^^^^                ------------
help: try using a conversion method
    |
160 |             return compiler_create_result(false, "".to_string(), errors, warnings);
    |                                                    ++++++++++++

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:164:19
    |
164 |     println!("{}".to_string(), "  [3/4] Semantic analysis...".to_string());
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:167:19
    |
167 |     println!("{}".to_string(), "  [4/4] Generating Rust code...".to_string());
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:171:23
    |
171 |         println!("{}".to_string(), "Debug: Generated Rust code length: ".to_string() + (rust_code).len());
    |                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:171:88
    |
171 |         println!("{}".to_string(), "Debug: Generated Rust code length: ".to_string() + (rust_code).len());
    |                                                                                        ^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:173:19
    |
173 |     println!("{}".to_string(), "FORCE DEBUG: Rust code length: ".to_string() + (rust_code).len());
    |                   ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:173:80
    |
173 |     println!("{}".to_string(), "FORCE DEBUG: Rust code length: ".to_string() + (rust_code).len());
    |                                                                                ^^^^^^^^^^^^^^^^^ expected `&str`, found `usize`

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:175:23
    |
175 |         println!("{}".to_string(), "Debug: Rust code preview:".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:176:23
    |
176 |         println!("{}".to_string(), rust_code);
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:185:23
    |
185 |         println!("{}".to_string(), "Compilation successful!".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:193:19
    |
193 |     println!("{}".to_string(), "ENTER compile_file".to_string());
    |                   ^^^^^^^^^ not found in this scope

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> main.rs:195:102
    |
195 | ...utput_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), ...
    |                                   ^^^                          ---- unexpected argument #2 of type `bool`
    |
note: expected `&_`, found `String`
   --> main.rs:195:106
    |
195 |     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), ...
    |                                                                                                          ^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected reference `&_`
                  found struct `String`
note: method defined here
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:909:12
    |
909 |     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
    |            ^^^
help: try removing the method call
    |
195 -     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
195 +     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust", true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
    |
help: remove the extra argument
    |
195 -     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
195 +     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get(/* k */), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
    |

error[E0308]: mismatched types
   --> main.rs:195:94
    |
195 | ... output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true)...
    |                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `Option<&String>`
    |
    = note: expected type `bool`
               found enum `Option<&String>`
help: use `Option::is_some` to test if the `Option` has a value
    |
195 |     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true).is_some(), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
    |                                                                                                                                        ++++++++++

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> main.rs:195:163
    |
195 | ...), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
    |                                ^^^                                ---- unexpected argument #2 of type `bool`
    |
note: expected `&_`, found `String`
   --> main.rs:195:167
    |
195 | ...t".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), ...
    |                                                        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected reference `&_`
                  found struct `String`
note: method defined here
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:909:12
    |
909 |     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
    |            ^^^
help: try removing the method call
    |
195 -     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
195 +     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics", true), verbose: options.get("verbose".to_string(), false)};
    |
help: remove the extra argument
    |
195 -     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
195 +     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get(/* k */), verbose: options.get("verbose".to_string(), false)};
    |

error[E0308]: mismatched types
   --> main.rs:195:155
    |
195 | ...ue), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `Option<&String>`
    |
    = note: expected type `bool`
               found enum `Option<&String>`
help: use `Option::is_some` to test if the `Option` has a value
    |
195 |     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true).is_some(), verbose: options.get("verbose".to_string(), false)};
    |                                                                                                                                                                                                           ++++++++++

error[E0061]: this method takes 1 argument but 2 arguments were supplied
   --> main.rs:195:222
    |
195 | ...ring(), true), verbose: options.get("verbose".to_string(), false)};
    |                                    ^^^                        ----- unexpected argument #2 of type `bool`
    |
note: expected `&_`, found `String`
   --> main.rs:195:226
    |
195 | ...eck_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
    |                                                            ^^^^^^^^^^^^^^^^^^^^^
    = note: expected reference `&_`
                  found struct `String`
note: method defined here
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/std/src/collections/hash/map.rs:909:12
    |
909 |     pub fn get<Q: ?Sized>(&self, k: &Q) -> Option<&V>
    |            ^^^
help: try removing the method call
    |
195 -     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
195 +     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose", false)};
    |
help: remove the extra argument
    |
195 -     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false)};
195 +     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get(/* k */)};
    |

error[E0308]: mismatched types
   --> main.rs:195:214
    |
195 | ...string(), true), verbose: options.get("verbose".to_string(), false)};
    |                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `bool`, found `Option<&String>`
    |
    = note: expected type `bool`
               found enum `Option<&String>`
help: use `Option::is_some` to test if the `Option` has a value
    |
195 |     let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust".to_string(), true), check_semantics: options.get("check_semantics".to_string(), true), verbose: options.get("verbose".to_string(), false).is_some()};
    |                                                                                                                                                                                                                                                               ++++++++++

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:199:19
    |
199 |     println!("{}".to_string(), "DEBUG: Result success: ".to_string() + &format!("{}".to_string(), result.success));
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:199:86
    |
199 |     println!("{}".to_string(), "DEBUG: Result success: ".to_string() + &format!("{}".to_string(), result.success));
    |                                                                                      ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:200:19
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |                   ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:200:85
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |                                                                                     ^^^^^^^^^ not found in this scope

error[E0609]: no field `fields` on type `CompileResult`
   --> main.rs:200:105
    |
200 |     println!("{}".to_string(), "DEBUG: Result fields: ".to_string() + &format!("{}".to_string(), result.fields));
    |                                                                                                         ^^^^^^ unknown field
    |
    = note: available fields are: `success`, `output_code`, `errors`, `warnings`

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:217:23
    |
217 |         println!("{}".to_string(), "GUL Compiler v0.1.0".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:218:23
    |
218 |         println!("{}".to_string(), "Usage: gul-compile <input.mn> [options]".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:219:23
    |
219 |         println!("{}".to_string(), "Options:".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:220:23
    |
220 |         println!("{}".to_string(), "  -o <file>      Output file (default: input.rs)".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:221:23
    |
221 |         println!("{}".to_string(), "  --verbose      Verbose output".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:222:23
    |
222 |         println!("{}".to_string(), "  --no-semantic  Skip semantic analysis".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:226:18
    |
210 |     let mut input_file = "";
    |                          -- expected due to this value
...
226 |     input_file = args[1];
    |                  ^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
226 |     input_file = &args[1];
    |                  +

error[E0308]: mismatched types
   --> main.rs:234:31
    |
211 |     let mut output_file = "";
    |                           -- expected due to this value
...
234 |                 output_file = args[i + 1];
    |                               ^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
234 |                 output_file = &args[i + 1];
    |                               +

error[E0277]: the trait bound `String: Pattern` is not satisfied
   --> main.rs:253:42
    |
253 |         output_file = input_file.replace(".mn".to_string(), ".rs".to_string());
    |                                  ------- ^^^^^^^^^^^^^^^^^ the trait `Pattern` is not implemented for `String`
    |                                  |
    |                                  required by a bound introduced by this call
    |
    = note: required for `String` to implement `Pattern`
note: required by a bound in `str::<impl str>::replace`
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:268:23
    |
268 |     pub fn replace<P: Pattern>(&self, from: P, to: &str) -> String {
    |                       ^^^^^^^ required by this bound in `str::<impl str>::replace`
help: consider borrowing here
    |
253 |         output_file = input_file.replace(&".mn".to_string(), ".rs".to_string());
    |                                          +

error[E0308]: mismatched types
   --> main.rs:253:61
    |
253 |         output_file = input_file.replace(".mn".to_string(), ".rs".to_string());
    |                                  -------                    ^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |                                  |
    |                                  arguments to this method are incorrect
    |
note: method defined here
   --> /home/vu/.rustup/toolchains/stable-x86_64-unknown-linux-gnu/lib/rustlib/src/rust/library/alloc/src/str.rs:268:12
    |
268 |     pub fn replace<P: Pattern>(&self, from: P, to: &str) -> String {
    |            ^^^^^^^
help: try removing the method call
    |
253 -         output_file = input_file.replace(".mn".to_string(), ".rs".to_string());
253 +         output_file = input_file.replace(".mn".to_string(), ".rs");
    |

error[E0308]: mismatched types
   --> main.rs:253:23
    |
211 |     let mut output_file = "";
    |                           -- expected due to this value
...
253 |         output_file = input_file.replace(".mn".to_string(), ".rs".to_string());
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
253 |         output_file = &input_file.replace(".mn".to_string(), ".rs".to_string());
    |                       +

error[E0308]: arguments to this function are incorrect
   --> main.rs:257:18
    |
257 |     let result = compile_file(input_file, output_file, HashMap::from([("emit_rust".to_string().to_string(), true), ("check_semantics".to_...
    |                  ^^^^^^^^^^^^ ----------  ----------- expected `String`, found `&str`
    |                               |
    |                               expected `String`, found `&str`
    |
note: expected `HashMap<String, String>`, found `HashMap<String, bool>`
   --> main.rs:257:56
    |
257 | ...e, HashMap::from([("emit_rust".to_string().to_string(), true), ("check_semantics".to_string().to_string(), check_semantics), ("verbose".to_string().to_string(), verbose)]));
    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
    = note: expected struct `HashMap<_, String>`
               found struct `HashMap<_, bool>`
note: function defined here
   --> main.rs:192:8
    |
192 | pub fn compile_file(input_file: String, output_file: String, options: HashMap<String, String>)  ->  CompileResult {
    |        ^^^^^^^^^^^^ ------------------  -------------------  --------------------------------
help: try using a conversion method
    |
257 |     let result = compile_file(input_file.to_string(), output_file, HashMap::from([("emit_rust".to_string().to_string(), true), ("check_semantics".to_string().to_string(), check_semantics), ("verbose".to_string().to_string(), verbose)]));
    |                                         ++++++++++++
help: try using a conversion method
    |
257 |     let result = compile_file(input_file, output_file.to_string(), HashMap::from([("emit_rust".to_string().to_string(), true), ("check_semantics".to_string().to_string(), check_semantics), ("verbose".to_string().to_string(), verbose)]));
    |                                                      ++++++++++++

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:260:23
    |
260 |         println!("{}".to_string(), "Compilation successful!".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:262:27
    |
262 |             println!("{}".to_string(), "Warnings: ".to_string() + &format!("{}".to_string(), (result.warnings).len()));
    |                           ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:262:81
    |
262 |             println!("{}".to_string(), "Warnings: ".to_string() + &format!("{}".to_string(), (result.warnings).len()));
    |                                                                                 ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:266:23
    |
266 |         println!("{}".to_string(), "Compilation failed!".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:268:23
    |
268 |         println!("{}".to_string(), "DEBUG: Result fields available? (Check interpreter debug)".to_string());
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:271:23
    |
271 |         println!("{}".to_string(), "DEBUG: errors var type: ".to_string() + &format!("{}".to_string(), "unknown".to_string()));
    |                       ^^^^^^^^^ not found in this scope

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:271:91
    |
271 |         println!("{}".to_string(), "DEBUG: errors var type: ".to_string() + &format!("{}".to_string(), "unknown".to_string()));
    |                                                                                           ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:272:12
    |
272 |         if errs {
    |            ^^^^ expected `bool`, found `Vec<String>`
    |
    = note: expected type `bool`
             found struct `Vec<String>`

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:273:27
    |
273 |             println!("{}".to_string(), "Errors list length: ".to_string() + (errs).len());
    |                           ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:273:77
    |
273 |             println!("{}".to_string(), "Errors list length: ".to_string() + (errs).len());
    |                                                                             ^^^^^^^^^^^^ expected `&str`, found `usize`

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:275:31
    |
275 |                 println!("{}".to_string(), "  ".to_string() + error);
    |                               ^^^^^^^^^ not found in this scope

error[E0308]: mismatched types
   --> main.rs:275:63
    |
275 |                 println!("{}".to_string(), "  ".to_string() + error);
    |                                                               ^^^^^ expected `&str`, found `String`
    |
help: consider borrowing here
    |
275 |                 println!("{}".to_string(), "  ".to_string() + &error);
    |                                                               +

error[E0425]: cannot find function `to_string` in this scope
   --> main.rs:279:27
    |
279 |             println!("{}".to_string(), "Result.errors is None || empty".to_string());
    |                           ^^^^^^^^^ not found in this scope

error[E0507]: cannot move out of index of `Vec<token::Token>`
  --> parser/parser.rs:73:16
   |
73 |         return self.tokens[self.current_pos];
   |                ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `token::Token`, which does not implement the `Copy` trait
   |
help: consider cloning the value if the performance cost is acceptable
   |
73 |         return self.tokens[self.current_pos].clone();
   |                                             ++++++++

error[E0507]: cannot move out of index of `Vec<token::Token>`
  --> parser/parser.rs:77:21
   |
77 |         let token = self.tokens[self.current_pos];
   |                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `token::Token`, which does not implement the `Copy` trait
   |
help: consider borrowing here
   |
77 |         let token = &self.tokens[self.current_pos];
   |                     +
help: consider cloning the value if the performance cost is acceptable
   |
77 |         let token = self.tokens[self.current_pos].clone();
   |                                                  ++++++++

error[E0507]: cannot move out of index of `Vec<token::Token>`
  --> parser/parser.rs:86:19
   |
86 |         let tok = self.tokens[self.current_pos];
   |                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `token::Token`, which does not implement the `Copy` trait
   |
help: consider borrowing here
   |
86 |         let tok = &self.tokens[self.current_pos];
   |                   +
help: consider cloning the value if the performance cost is acceptable
   |
86 |         let tok = self.tokens[self.current_pos].clone();
   |                                                ++++++++

error[E0507]: cannot move out of index of `Vec<token::Token>`
   --> parser/parser.rs:114:23
    |
114 |             let tok = self.tokens[self.current_pos];
    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ move occurs because value has type `token::Token`, which does not implement the `Copy` trait
    |
help: consider borrowing here
    |
114 |             let tok = &self.tokens[self.current_pos];
    |                       +
help: consider cloning the value if the performance cost is acceptable
    |
114 |             let tok = self.tokens[self.current_pos].clone();
    |                                                    ++++++++

error[E0391]: cycle detected when computing when `semantic::analyzer::Scope` needs drop
  --> semantic/analyzer.rs:20:1
   |
20 | pub struct Scope {
   | ^^^^^^^^^^^^^^^^
   |
   = note: ...which immediately requires computing when `semantic::analyzer::Scope` needs drop again
   = note: cycle used when computing whether `semantic::analyzer::Scope` needs drop
   = note: see https://rustc-dev-guide.rust-lang.org/overview.html#queries and https://rustc-dev-guide.rust-lang.org/query.html for more information

error[E0308]: mismatched types
   --> parser/parser.rs:196:145
    |
196 | ... name, params: vec![], body: body, return_type: "Any"});
    |                                                    ^^^^^ expected `String`, found `&str`
    |
help: try using a conversion method
    |
196 |             return Statement::FunctionDecl(FunctionDecl{node: ASTNode{line: 1, column: 1}, name: name, params: vec![], body: body, return_type: "Any".to_string()});
    |                                                                                                                                                      ++++++++++++

Some errors have detailed explanations: E0034, E0061, E0063, E0072, E0277, E0308, E0317, E0369, E0391...
For more information about an error, try `rustc --explain E0034`.
warning: `gul-compiler` (bin "gul-compile") generated 35 warnings
error: could not compile `gul-compiler` (bin "gul-compile") due to 615 previous errors; 35 warnings emitted

ðŸŽ‰ SUCCESS! GUL compiler built successfully!

Compiler location: compiler_rust/target/release/gul-compile

Test it with:
  ./target/release/gul-compile --help

Build process complete!
