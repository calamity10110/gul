# GUL v3.2 Compiler - Recursive Descent Parser
@imp compiler.lexer.token
@imp compiler.ast.nodes

# Enumeration for operator precedence
enum Precedence:
    NoPrec
    Assignment
    Or
    And
    Comparison
    Term
    Factor
    Power
    Range
    Prefix
    Call
    Index
    Unpack

fn get_precedence(token_type: TokenType) -> Precedence:
    """Get the precedence level for a given token type"""
    if token_type == TokenType.Equal:
        return Precedence.Assignment
    elif token_type == TokenType.Or or token_type == TokenType.Not:
        return Precedence.Or
    elif token_type == TokenType.And:
        return Precedence.And
    elif token_type == TokenType.EqualEqual or token_type == TokenType.NotEqual:
        return Precedence.Comparison
    elif token_type == TokenType.Less or token_type == TokenType.LessEq or token_type == TokenType.Greater or token_type == TokenType.GreaterEq:
        return Precedence.Comparison
    elif token_type == TokenType.Plus or token_type == TokenType.Minus:
        return Precedence.Term
    elif token_type == TokenType.Star or token_type == TokenType.Slash or token_type == TokenType.Percent:
        return Precedence.Factor
    elif token_type == TokenType.DoubleStar:
        return Precedence.Power
    elif token_type == TokenType.LeftParen or token_type == TokenType.LeftBracket or token_type == TokenType.Dot:
        return Precedence.Call
    return Precedence.NoPrec

struct Parser:
    tokens: @list[Token]
    current_pos: @int
    errors: @list[@str]
    
impl Parser:
    fn create(tokens: @list[Token]) -> Parser:
        return Parser{tokens: tokens, current_pos: @int(0), errors: @list[]}
    
    fn is_at_end(ref self) -> @bool:
        let size = len(self.tokens)
        return self.current_pos >= size - 1
    
    fn current(ref self) -> Token:
        return self.tokens[self.current_pos]
    
    fn advance(ref self) -> Token:
        let token = self.tokens[self.current_pos]
        let size = len(self.tokens)
        if self.current_pos < size - 1:
            self.current_pos = self.current_pos + 1
        return token
    
    fn match_token(ref self, expected_type: TokenType) -> @bool:
        let tok = self.tokens[self.current_pos]
        if tok.token_type == expected_type:
            let size = len(self.tokens)
            if self.current_pos < size - 1:
                self.current_pos = self.current_pos + 1
            return true
        return false
    
    fn expect(ref self, expected_type: TokenType, message: @str) -> Token:
        let tok = self.tokens[self.current_pos]
        if tok.token_type == expected_type:
            let size = len(self.tokens)
            if self.current_pos < size - 1:
                self.current_pos = self.current_pos + 1
            return tok
        print("Parse error: " + message)
        return tok # fallthrough
        
    fn parse_expression(ref self, min_precedence: Precedence) -> Expression:
        var left = self.parse_prefix()
        while @bool(true):
            if self.current_pos >= len(self.tokens) - 1: break
            let tok = self.tokens[self.current_pos]
            let prec = get_precedence(tok.token_type)
            if prec <= min_precedence: break
            left = self.parse_infix(left, prec)
        return left

    fn parse_prefix(ref self) -> Expression:
        let token = self.advance()
        let t_type = token.token_type
        if t_type == TokenType.Identifier:
            return IdentifierExpr{node: ASTNode{line: 1, column: 1}, name: token.value}
        elif t_type == TokenType.Integer:
            return LiteralExpr{node: ASTNode{line: 1, column: 1}, value: token.value, value_type: TokenType.Integer}
        elif t_type == TokenType.LeftParen:
            let expr = self.parse_expression(Precedence.NoPrec)
            self.expect(TokenType.RightParen, "Expected ')'")
            return expr
        elif t_type == TokenType.Minus:
            let op = self.parse_expression(Precedence.Prefix)
            return UnaryOpExpr{node: ASTNode{line: 1, column: 1}, operator: TokenType.Minus, operand: op}
        return LiteralExpr{node: ASTNode{line: 1, column: 1}, value: "None", value_type: TokenType.NoneLiteral}

    fn parse_infix(ref self, left: Expression, precedence: Precedence) -> Expression:
        let token = self.advance()
        if token.token_type == TokenType.Plus or token.token_type == TokenType.Minus or token.token_type == TokenType.Star or token.token_type == TokenType.Slash:
            let right = self.parse_expression(precedence)
            return BinaryOpExpr{node: ASTNode{line: 1, column: 1}, left: left, operator: token.token_type, right: right}
        elif token.token_type == TokenType.LeftParen:
            let args = @list[]
            if not (self.tokens[self.current_pos].token_type == TokenType.RightParen):
                args.add(self.parse_expression(Precedence.NoPrec))
                while self.match_token(TokenType.Comma):
                    args.add(self.parse_expression(Precedence.NoPrec))
            self.expect(TokenType.RightParen, "Expected ')'")
            return CallExpr{node: ASTNode{line: 1, column: 1}, callee: left, arguments: args}
        return left

    fn parse_statement(ref self) -> Statement:
        let tok = self.tokens[self.current_pos]
        if tok.token_type == TokenType.Let:
            self.advance()
            let name = self.expect(TokenType.Identifier, "Expected identifier").value
            self.expect(TokenType.Equal, "Expected '='")
            let val = self.parse_expression(Precedence.NoPrec)
            return LetStmt{node: ASTNode{line: 1, column: 1}, name: name, value: val, is_var: @bool(false)}
        elif tok.token_type == TokenType.Return:
            self.advance()
            let val = self.parse_expression(Precedence.NoPrec)
            return ReturnStmt{node: ASTNode{line: 1, column: 1}, value: val}
        elif tok.token_type == TokenType.Fn:
            self.advance()
            let name = self.expect(TokenType.Identifier, "Expected function name").value
            self.expect(TokenType.LeftParen, "Expected '('")
            let params = @list[] # simplified
            while not (self.tokens[self.current_pos].token_type == TokenType.RightParen):
                self.advance() # consume param
                if self.tokens[self.current_pos].token_type == TokenType.Comma: self.advance()
            self.advance() # )
            self.expect(TokenType.Colon, "Expected ':'")
            self.expect(TokenType.Newline, "Expected Newline")
            self.expect(TokenType.Indent, "Expected Indent")
            let body = @list[]
            while not (self.tokens[self.current_pos].token_type == TokenType.Dedent):
                body.add(self.parse_statement())
                if self.tokens[self.current_pos].token_type == TokenType.Newline: self.advance()
            self.advance() # Dedent
            return FunctionDecl{node: ASTNode{line: 1, column: 1}, name: name, params: @list[], body: body, return_type: "Any"}
        
        # Expression statement
        let expr = self.parse_expression(Precedence.NoPrec)
        return ExpressionStmt{node: ASTNode{line: 1, column: 1}, expression: expr}

    fn parse_program(ref self) -> Program:
        let statements = @list[]
        print("    Parser: parse_program start")
        while self.current_pos < len(self.tokens) - 1:
            print("    Parser POS: " + str(self.current_pos))
            let tok = self.tokens[self.current_pos]
            if tok.token_type == TokenType.Newline:
                self.advance()
            else:
                statements.add(self.parse_statement())
        return Program{statements: statements, imports: @list[], main_entry: @list[]}

fn parse(tokens: @list[Token]) -> Program:
    var parser = Parser.create(tokens)
    return parser.parse_program()
# GUL v3.2 Compiler - Statement Parser Extension
# Adds statement parsing to the parser

# This file extends the Parser struct with statement parsing methods
# It should be concatenated with parser.mn or imported

# Note: In the actual implementation, these methods would be added to the Parser struct
# For this demo, showing the logical structure

# ========================================
# STATEMENT PARSING METHODS (add to Parser)
# ========================================

impl Parser:
    fn parse_statement(ref self) -> Statement:
        """Parse a single statement"""
        self.skip_newlines()
        
        let token = self.current()
        
        match token.token_type:
            # Declarations (TODO)
            TokenType.Let => return self.parse_let_statement()
            TokenType.Var => return self.parse_var_statement()
            TokenType.Fn => return self.parse_function_declaration()
            # TokenType.Async => return self.parse_async_function_declaration()
            # TokenType.Struct => return self.parse_struct_declaration()
            # TokenType.Enum => return self.parse_enum_declaration()
            
            # Control flow
            TokenType.If => return self.parse_if_statement()
            TokenType.While => return self.parse_while_statement()
            TokenType.For => return self.parse_for_statement()
            # TokenType.Loop => return self.parse_loop_statement()
            # TokenType.Match => return self.parse_match_statement()
            
            # Flow control
            # TokenType.Break => return self.parse_break_statement()
            # TokenType.Continue => return self.parse_continue_statement()
            TokenType.Return => return self.parse_return_statement()
            
            # Error handling
            # TokenType.Try => return self.parse_try_statement()
            
            # Imports
            TokenType.AtImp => return self.parse_import()
            
            # Foreign code
            # TokenType.AtPython => return self.parse_foreign_block("python")
            # TokenType.AtRust => return self.parse_foreign_block("rust")
            # TokenType.AtJs => return self.parse_foreign_block("js")
            # TokenType.AtSql => return self.parse_foreign_block("sql")
            
            _ =>
                # Try parsing as expression statement or assignment
                return self.parse_expression_or_assignment()
    
    fn parse_let_statement(ref self) -> Statement:
        """Parse let declaration: let x = 5 or let x: int = 5"""
        let let_token = self.advance()
        
        let name_token = self.expect(TokenType.Identifier, "Expected variable name after 'let'")
        let name = name_token.value
        
        var type_annotation = @str("")
        if self.match_token(TokenType.Colon):
            let type_token = self.expect(TokenType.Identifier, "Expected type after ':'")
            type_annotation = type_token.value
        
        self.expect(TokenType.Equal, "Expected '=' in let declaration")
        let value = self.parse_expression()
        
        return LetStmt{
            node: create_node(let_token.line, let_token.column),
            name: name,
            type_annotation: type_annotation,
            value: value,
        };
    
    fn parse_var_statement(ref self) -> Statement:
        """Parse var declaration: var x = 5"""
        let var_token = self.advance()
        
        let name_token = self.expect(TokenType.Identifier, "Expected variable name after 'var'")
        let name = name_token.value
        
        var type_annotation = @str("")
        if self.match_token(TokenType.Colon):
            let type_token = self.expect(TokenType.Identifier, "Expected type after ':'")
            type_annotation = type_token.value
        
        self.expect(TokenType.Equal, "Expected '=' in var declaration")
        let value = self.parse_expression()
        
        return VarStmt{
            node: create_node(var_token.line, var_token.column),
            name: name,
            type_annotation: type_annotation,
            value: value,
        };
    
    fn parse_function_declaration(ref self) -> Statement:
        """Parse function: fn add(a, b) -> int: ..."""
        let fn_token = self.advance()
        
        # Optional return type annotation before name
        var return_type = @str("")
        if self.current().token_type == TokenType.AtInt or self.current().token_type == TokenType.AtStr:
            let type_token = self.advance()
            return_type = type_token.value.chars().skip(1).collect()  # Remove @
        
        let name_token = self.expect(TokenType.Identifier, "Expected function name")
        let name = name_token.value
        
        # Parameters
        self.expect(TokenType.LeftParen, "Expected '(' after function name")
        var parameters = @list[]
        
        while not self.match_token(TokenType.RightParen):
            let param = self.parse_parameter()
            parameters.add(param)
            if not self.match_token(TokenType.Comma):
                self.expect(TokenType.RightParen, "Expected ')' or ',' in parameters")
                break
        
        # Return type after params
        if self.match_token(TokenType.Arrow):
            let type_token = self.expect(TokenType.Identifier, "Expected return type after '->'")
            return_type = type_token.value
        
        # Body
        self.expect(TokenType.Colon, "Expected ':' before function body")
        self.skip_newlines()
        self.expect(TokenType.Indent, "Expected indented block for function body")
        
        let body = self.parse_block()
        
        return FunctionDecl{
            node: create_node(fn_token.line, fn_token.column),
            name: name,
            is_async: @bool(false),
            parameters: parameters,
            return_type: return_type,
            body: body,
            decorators: @list[],
        };
    
    fn parse_parameter(ref self) -> Parameter:
        """Parse function parameter: name: type or name"""
        let name_token = self.expect(TokenType.Identifier, "Expected parameter name")
        var type_annotation = @str("")
        var ownership_mode = @str("")
        
        # Optional type annotation
        if self.match_token(TokenType.Colon):
            # Check for ownership mode
            if self.current().token_type == TokenType.Borrow or self.current().token_type == TokenType.Ref or self.current().token_type == TokenType.Move or self.current().token_type == TokenType.Kept:
                ownership_mode = self.advance().value
            
            let type_token = self.expect(TokenType.Identifier, "Expected parameter type")
            type_annotation = type_token.value
        
        return Parameter{
            name: name_token.value,
            type_annotation: type_annotation,
            ownership_mode: ownership_mode,
            default_value: None,  # TODO: parse default values
        };
    
    fn parse_block(ref self) -> @list[Statement]:
        """Parse indented block of statements"""
        var statements = @list[]
        
        while not self.is_at_end() and self.current().token_type != TokenType.Dedent:
            self.skip_newlines()
            if self.current().token_type == TokenType.Dedent:
                break
            statements.add(self.parse_statement())
        
        self.match_token(TokenType.Dedent)  # Consume dedent
        return statements
    
    fn parse_if_statement(ref self) -> Statement:
        """Parse if statement with elif and else"""
       let if_token = self.advance()
        
        let condition = self.parse_expression()
        self.expect(TokenType.Colon, "Expected ':' after if condition")
        self.skip_newlines()
        self.expect(TokenType.Indent, "Expected indented block")
        
        let then_body = self.parse_block()
        
        var elif_clauses = @list[]
        var else_body = @list[]
        
        # Parse elif clauses
        while self.current().token_type == TokenType.Elif:
            self.advance()
            let elif_condition = self.parse_expression()
            self.expect(TokenType.Colon, "Expected ':' after elif condition")
            self.skip_newlines()
            self.expect(TokenType.Indent, "Expected indented block")
            let elif_body = self.parse_block()
            
            let clause = ElifClause{
                condition: elif_condition,
                body: elif_body,
            };
        elif_clauses.add(clause);

        
        # Parse else clause
        if self.match_token(TokenType.Else):
            self.expect(TokenType.Colon, "Expected ':' after else")
            self.skip_newlines()
            self.expect(TokenType.Indent, "Expected indented block")
            else_body = self.parse_block()
        
        return IfStmt{
            node: create_node(if_token.line, if_token.column),
            condition: condition,
            then_body: then_body,
            elif_clauses: elif_clauses,
            else_body: else_body,
        };
    
    fn parse_while_statement(ref self) -> Statement:
        """Parse while loop"""
        let while_token = self.advance()
        let condition = self.parse_expression()
        self.expect(TokenType.Colon, "Expected ':' after while condition")
        self.skip_newlines()
        self.expect(TokenType.Indent, "Expected indented block")
        let body = self.parse_block()
        
        return WhileStmt{
            node: create_node(while_token.line, while_token.column),
            condition: condition,
            body: body,
        };
    
    fn parse_for_statement(ref self) -> Statement:
        """Parse for loop: for x in items:"""
        let for_token = self.advance()
        let var_token = self.expect(TokenType.Identifier, "Expected variable in for loop")
        self.expect(TokenType.In, "Expected 'in' in for loop")
        let iterable = self.parse_expression()
        self.expect(TokenType.Colon, "Expected ':' after for")
        self.skip_newlines()
        self.expect(TokenType.Indent, "Expected indented block")
        let body = self.parse_block()
        
        return ForStmt{
            node: create_node(for_token.line, for_token.column),
            variable: var_token.value,
            iterable: iterable,
            body: body,
        };
    
    fn parse_return_statement(ref self) -> Statement:
        """Parse return statement"""
        let return_token = self.advance()
        var value = None
        
        # Check if there's a value to return
        if self.current().token_type != TokenType.Newline and self.current().token_type != TokenType.Eof:
            value = self.parse_expression()
        
        return ReturnStmt{
            node: create_node(return_token.line, return_token.column),
            value: value,
        };
    
    fn parse_import(ref self) -> Statement:
        """Parse import: @imp std.io or @imp std{io, http}"""
        let imp_token = self.advance()
        
        var module_path = @list[]
        var items = @list[]
        
        # Parse module path: std.io.file
        let first_part = self.expect(TokenType.Identifier, "Expected module name")
        module_path.add(first_part.value)
        
        while self.match_token(TokenType.Dot):
            let part = self.expect(TokenType.Identifier, "Expected module part")
            module_path.add(part.value)
        
        # Check for {item1, item2} syntax
        if self.match_token(TokenType.LeftBrace):
            while not self.match_token(TokenType.RightBrace):
                let item = self.expect(TokenType.Identifier, "Expected import item")
                items.add(item.value)
                if not self.match_token(TokenType.Comma):
                    self.expect(TokenType.RightBrace, "Expected '}' or ','")
                    break
        
        return ImportStmt{
            node: create_node(imp_token.line, imp_token.column),
            module_path: module_path,
            import_type: "single",
            items: items,
        };
    
    fn parse_expression_or_assignment(ref self) -> Statement:
        """Parse expression statement or assignment"""
        let start_pos = self.current_pos
        let expr = self.parse_expression()
        
        # Check if it's an assignment
        if self.current().token_type == TokenType.Equal or self.current().token_type == TokenType.PlusEq or self.current().token_type == TokenType.MinusEq or self.current().token_type == TokenType.StarEq or self.current().token_type == TokenType.SlashEq:
            let op = self.advance()
            let value = self.parse_expression()
            
            return AssignmentStmt{
                node: expr.node,
                target: expr,
                operator: op.token_type,
                value: value,
            };
        
        # It's just an expression statement
        return ExpressionStmt{
            node: expr.node,
            expression: expr,
        };

    fn skip_newlines(ref self):
        while self.current_pos < len(self.tokens) and self.tokens[self.current_pos].token_type == TokenType.Newline:
            self.advance()
