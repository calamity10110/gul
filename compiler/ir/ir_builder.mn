@imp compiler.ir.ir_nodes
@imp compiler.ast.nodes
@imp compiler.builtins.codegen_helpers
@imp std.collections

struct IRBuilder:
    current_module: IRModule,
    current_struct: @str,
    pending_impls: HashMap<String, Vec<IRFunction>>

impl IRBuilder:
    fn create() -> IRBuilder:
        return IRBuilder {
            current_module: IRModule {
                base: IRNode {node_type: IRNodeType.Module, line: 0, column: 0},
                name: "",
                imports: @list[],
                structs: @list[],
                impls: @list[],
                functions: @list[]
            },
            current_struct: "",
            pending_impls: @dict{}
        }
    
    fn build_module(ref self, ast: Module) -> IRModule:
        self.current_module.name = ast.name
        for stmt in ast.body:
            self.process_statement(stmt)
        self.finalize_impls()
        return self.current_module
    
    fn process_statement(ref self, stmt: Statement):
        if stmt.stmt_type == StmtType.StructDecl:
            self.process_struct(stmt)
        elif stmt.stmt_type == StmtType.FunctionDecl:
            self.process_function(stmt)
        elif stmt.stmt_type == StmtType.ImportStmt:
            self.process_import(stmt)
    
    fn process_struct(ref self, stmt: Statement):
        let decl = stmt
        var ir_struct = IRStruct {base: IRNode {node_type: IRNodeType.Struct, line: stmt.base.line, column: stmt.base.column}, name: decl.name, fields: @list[]}
        self.current_struct = decl.name
        for member in decl.body:
            if member.stmt_type == StmtType.FieldDecl:
                let field = IRField {base: IRNode {node_type: IRNodeType.Field, line: member.base.line, column: member.base.column}, name: member.name, type_name: gul_type_to_rust(member.type_annotation), default_value: ""}
                ir_struct.fields.add(field)
            elif member.stmt_type == StmtType.FunctionDecl:
                let ir_func = self.build_function(member)
                if !self.pending_impls.contains_key(decl.name):
                    self.pending_impls[decl.name] = @list[]
                self.pending_impls[decl.name].add(ir_func)
        self.current_module.structs.add(ir_struct)
        self.current_struct = ""

    fn process_function(ref self, stmt: Statement):
        let ir_func = self.build_function(stmt)
        self.current_module.functions.add(ir_func)

    fn build_function(ref self, decl: FunctionDecl) -> IRFunction:
        var ir_func = IRFunction {base: IRNode {node_type: IRNodeType.Function, line: decl.base.line, column: decl.base.column}, name: decl.name, params: @list[], return_type: gul_type_to_rust(decl.return_type), body: @list[], is_method: @bool(false), receiver: ""}
        for param in decl.parameters:
            if param.name == "self" or param.name == "ref self":
                ir_func.is_method = @bool(true)
                ir_func.receiver = param.name
            else:
                let ir_param = IRParameter {base: IRNode {node_type: IRNodeType.Parameter, line: param.base.line, column: param.base.column}, name: param.name, type_name: gul_type_to_rust(param.type_annotation), ownership: param.ownership_mode}
                ir_func.params.add(ir_param)
        return ir_func

    fn process_import(ref self, stmt: Statement):
        let parts = stmt.module_path
        var path = ""
        for part in parts:
            if len(path) > 0:
                path = path + "::"
            path = path + part
        self.current_module.imports.add(path)

    fn finalize_impls(ref self):
        pass

