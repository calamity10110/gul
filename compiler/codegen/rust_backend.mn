# GUL v3.2 Compiler - Rust Code Generator
# Transpiles GUL AST to Rust code

@imp std.collections
@imp std.io
@imp compiler.ast.nodes
@imp compiler.lexer.token

# Code generator state
struct CodeGenerator:
    output: @list[@str]  # Lines of generated Rust code
    indent_level: @int

impl CodeGenerator:
    fn create() -> CodeGenerator:
        return CodeGenerator {
            output: @list[],
            indent_level: @int(0)
        }
    
    fn indent(ref self):

        """Increase indentation level"""
        self.indent_level = self.indent_level + 1
    
    fn dedent(ref self):
        """Decrease indentation level"""
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1
    
    fn emit(ref self, code: @str):
        """Emit a line of code with current indentation"""
        let indent_str = "    " * self.indent_level
        self.output.add(f"{indent_str}{code}")
    
    fn emit_raw(ref self, code: @str):
        """Emit code without indentation"""
        self.output.add(code)
    
    fn get_output(self) -> @str:
        """Get generated code as string"""
        return "\n".join(self.output)
    
    # ========================================
    # PROGRAM GENERATION
    # ========================================
    
    fn generate_program(ref self, program: Program):
        """Generate code for entire program"""
        # Emit standard imports
        self.emit_raw("// Generated by GUL compiler")
        self.emit_raw("")
        
        # Generate imports
        for import_stmt in program.imports:
            self.generate_import(import_stmt)
        
        if len(program.imports) > 0:
            self.emit_raw("")
        
        # Generate statements
        for stmt in program.statements:
            self.generate_statement(stmt)
        
        # Generate main entry point
        if len(program.main_entry) > 0:
            self.emit_raw("")
            self.emit("fn main() {")
            self.indent()
            for stmt in program.main_entry:
                self.generate_statement(stmt)
            self.dedent()
            self.emit("}")
    
    # ========================================
    # STATEMENT GENERATION
    # ========================================
    
    fn generate_statement(ref self, stmt: &Statement):
        match stmt:
            Statement.LetDecl(s) => self.generate_let(s)
            Statement.VarDecl(s) => self.generate_var(s)
            Statement.FunctionDecl(s) => self.generate_function(s)
            Statement.IfStmt(s) => self.generate_if(s)
            Statement.WhileStmt(s) => self.generate_while(s)
            Statement.ForStmt(s) => self.generate_for(s)
            Statement.ReturnStmt(s) => self.generate_return(s)
            Statement.AssignmentStmt(s) => self.generate_assignment(s)
            Statement.ExpressionStmt(s) => self.generate_expression_stmt(s)
            Statement.StructDecl(s) => self.emit("// Struct decl") # TODO
            Statement.EnumDecl(s) => self.emit("// Enum decl") # TODO
            Statement.ImportStmt(s) => self.generate_import(s)
            Statement.PassStmt(s) => pass
            _ => self.emit_raw("// Unsupported statement")
    fn generate_let(ref self, stmt: &LetStmt):
        """Generate let declaration"""
        var code = f"let {stmt.name}"
        if stmt.type_annotation: code = f"{code}: {self.map_type(stmt.type_annotation)}"
        code = f"{code} = {self.generate_expression_str(stmt.value)};"
        self.emit(code)
    
    fn generate_var(ref self, stmt: &VarStmt):
        """Generate var declaration (mutable)"""
        var code = f"let mut {stmt.name}"
        if stmt.type_annotation: code = f"{code}: {self.map_type(stmt.type_annotation)}"
        code = f"{code} = {self.generate_expression_str(stmt.value)};"
        self.emit(code)
    
    fn generate_function(ref self, stmt: &FunctionDecl):
        """Generate function declaration"""
        var signature = f"fn {stmt.name}("
        var params = @list[]
        for param in &stmt.parameters:
            var param_str = param.name
            if param.type_annotation: param_str = f"{param_str}: {self.map_type(param.type_annotation)}"
            params.add(param_str)
        signature = signature + ", ".join(params) + ")"
        if stmt.return_type: signature = f"{signature} -> {self.map_type(stmt.return_type)}"
        signature = signature + " {"
        self.emit(signature)
        self.indent()
        for body_stmt in &stmt.body: self.generate_statement(body_stmt)
        self.dedent()
        self.emit("}")
        self.emit_raw("")
    
    fn generate_if(ref self, stmt: &IfStmt):
        """Generate if statement"""
        let condition = self.generate_expression_str(stmt.condition)
        self.emit(f"if {condition}" + " {")
        
        self.indent()
        for s in &stmt.then_body:
            self.generate_statement(s)
        self.dedent()
        
        # Elif clauses
        for elif_clause in &stmt.elif_clauses:
            let elif_cond = self.generate_expression_str(elif_clause.condition)
            self.emit("} else if " + f"{elif_cond}" + " {")
            self.indent()
            for s in &elif_clause.body:
                self.generate_statement(s)
            self.dedent()
        
        # Else clause
        if len(stmt.else_body) > 0:
            self.emit("} else {")
            self.indent()
            for s in &stmt.else_body:
                self.generate_statement(s)
            self.dedent()
        
        self.emit("}")
    
    fn generate_while(ref self, stmt: &WhileStmt):
        """Generate while loop"""
        let condition = self.generate_expression_str(stmt.condition)
        self.emit(f"while {condition}" + " {")
        
        self.indent()
        for s in &stmt.body:
            self.generate_statement(s)
        self.dedent()
        self.emit("}")
    
    fn generate_for(ref self, stmt: &ForStmt):
        """Generate for loop"""
        let iterable = self.generate_expression_str(stmt.iterable)
        self.emit(f"for {stmt.variable} in {iterable}" + " {")
        
        self.indent()
        for s in &stmt.body:
            self.generate_statement(s)
        self.dedent()
        self.emit("}")
    
    fn generate_return(ref self, stmt: &ReturnStmt):
        """Generate return statement"""
        if stmt.value:
            let value = self.generate_expression_str(stmt.value)
            self.emit(f"return {value};")
        else:
            self.emit("return;")
    
    fn generate_assignment(ref self, stmt: &AssignmentStmt):
        """Generate assignment"""
        let target = self.generate_expression_str(stmt.target)
        let value = self.generate_expression_str(stmt.value)
        
        # Handle compound assignments
        var op = "="
        if stmt.operator == TokenType.PlusEq:
            op = "+="
        elif stmt.operator == TokenType.MinusEq:
            op = "-="
        elif stmt.operator == TokenType.StarEq:
            op = "*="
        elif stmt.operator == TokenType.SlashEq:
            op = "/="
        
        self.emit(f"{target} {op} {value};")
    
    fn generate_expression_stmt(ref self, stmt: &ExpressionStmt):
        """Generate expression statement"""
        let expr = self.generate_expression_str(stmt.expression)
        self.emit(expr + ";")
    
    fn generate_import(ref self, stmt: &ImportStmt):
        """Generate import (as Rust use statement)"""
        let module = "::".join(stmt.module_path)
        
        if len(stmt.items) > 0:
            let items = ", ".join(items)
            self.emit_raw("use " + module + "::{" + items + "};")
        else:
            self.emit_raw("use " + module + ";")
    
    # ========================================
    # EXPRESSION GENERATION
    # ========================================
    
    fn generate_expression_str(ref self, expr: &Expression) -> @str:
        match expr:
            Expression.Literal(lit) =>
                 if lit.value_type == TokenType.StringLiteral: return self.generate_string_literal(lit)
                 else: return self.generate_literal(lit)
            Expression.Identifier(id) => return self.generate_identifier(id)
            Expression.BinaryOp(op) => return self.generate_binary_op(op)
            Expression.UnaryOp(op) => return self.generate_unary_op(op)
            Expression.Call(call) => return self.generate_call(call)
            Expression.Index(idx) => return self.generate_index(idx)
            Expression.Attribute(attr) => return self.generate_attribute(attr)
            Expression.List(l) => return self.generate_list(l)
            Expression.Tuple(t) => return self.generate_tuple(t)
            Expression.Set(s) => return self.generate_set(s) 
            Expression.Dict(d) => return self.generate_dict(d)
            Expression.Lambda(l) => return "lambda_todo"
            Expression.Match(m) => return "match_todo"
            Expression.Grouped(g) => return "(" + self.generate_expression_str(g.expression) + ")"
            _ => return "unknown_expr"
        return "/* unsupported expression */"
    
    fn generate_literal(ref self, expr: LiteralExpr) -> @str:
        """Generate literal value"""
        return expr.value
    
    fn generate_string_literal(ref self, expr: LiteralExpr) -> @str:
        """Generate string literal with quotes"""
        return "\"" + expr.value + "\""
    
    fn generate_identifier(ref self, expr: &IdentifierExpr) -> @str:
        """Generate identifier"""
        return expr.name
    
    fn generate_binary_op(ref self, expr: &BinaryOpExpr) -> @str:
        let left = self.generate_expression_str(expr.left)
        let right = self.generate_expression_str(expr.right)
        let op_t = expr.operator
        var op = ""
        
        if op_t == TokenType.Plus: op = "+"
        elif op_t == TokenType.Minus: op = "-"
        elif op_t == TokenType.Star: op = "*"
        elif op_t == TokenType.Slash: op = "/"
        elif op_t == TokenType.Percent: op = "%"
        elif op_t == TokenType.DoubleStar: return f"{left}.pow({right})" # TODO: cast for pow?
        elif op_t == TokenType.EqualEqual: op = "=="
        elif op_t == TokenType.NotEqual: op = "!="
        elif op_t == TokenType.Greater: op = ">"
        elif op_t == TokenType.Less: op = "<"
        elif op_t == TokenType.GreaterEq: op = ">="
        elif op_t == TokenType.LessEq: op = "<="
        elif op_t == TokenType.And: op = "&&"
        elif op_t == TokenType.Or: op = "||"
        elif op_t == TokenType.DotDot: return f"{left}..{right}"
        elif op_t == TokenType.DotDotEq: return f"{left}..={right}"
        else: op = "?"
        return f"({left} {op} {right})"
    
    fn generate_unary_op(ref self, expr: &UnaryOpExpr) -> @str:
        """Generate unary operation"""
        let operand = self.generate_expression_str(expr.operand)
        
        if expr.operator == TokenType.Minus:
            return f"-{operand}"
        elif expr.operator == TokenType.Not:
            return f"!{operand}"
        else:
            return f"?{operand.to_string()}"
    
    fn generate_call(ref self, expr: &CallExpr) -> @str:
        """Generate function call"""
        let callee = self.generate_expression_str(expr.callee)
        
        var args = @list[]
        for arg in &expr.arguments:
            args.add(self.generate_expression_str(arg))
        
        let args_str = ", ".join(args)
        return f"{callee}({args_str})"
    
    fn generate_index(ref self, expr: &IndexExpr) -> @str:
        """Generate index operation"""
        let object = self.generate_expression_str(expr.object)
        let index = self.generate_expression_str(expr.index)
        return f"{object}[{index}]"
    
    fn generate_attribute(ref self, expr: &AttributeExpr) -> @str:
        """Generate attribute access"""
        let object = self.generate_expression_str(expr.object)
        return f"{object}.{expr.attribute}"
    
    fn generate_list(ref self, expr: &ListExpr) -> @str:
        """Generate list literal"""
        var elements = @list[]
        for elem in &expr.elements:
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements)
        return f"vec![{elems_str}]"
    
    fn generate_tuple(ref self, expr: &TupleExpr) -> @str:
        """Generate tuple literal"""
        var elements = @list[]
        for elem in &expr.elements:
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements)
        return f"({elems_str})"
    
    fn generate_set(ref self, expr: &SetExpr) -> @str:
        """Generate set literal"""
        var elements = @list[]
        for elem in &expr.elements:
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements)
        return f"HashSet::from([{elems_str}])"
    
    fn generate_dict(ref self, expr: &DictExpr) -> @str:
        """Generate dictionary literal"""
        var pairs = @list[]
        for pair in &expr.pairs:
            let key = self.generate_expression_str(pair[0])
            let value = self.generate_expression_str(pair[1])
            pairs.add(f"({key}, {value})")
        
        let pairs_str = ", ".join(pairs)
        return f"HashMap::from([{pairs_str}])"
    
    fn generate_type_constructor(ref self, expr: &TypeConstructorExpr) -> @str:
        """Generate type constructor/cast"""
        let arg = self.generate_expression_str(expr.argument)
        
        match expr.type_name:
            "int" => return f"({arg} as i64)"
            "float" => return f"({arg} as f64)"
            "str" => return f"({arg}.to_string())"
            "bool" => return f"({arg} as bool)"
            _ => return f"{arg} /* {expr.type_name} */"
    
    # ========================================
    # TYPE MAPPING
    # ========================================
    
    fn map_type(self, gul_type: @str) -> @str:
        if gul_type == "int": return "i64"
        if gul_type == "float": return "f64"
        if gul_type == "str": return "String"
        if gul_type == "bool": return "bool"
        if gul_type == "list": return "Vec<_>"
        if gul_type == "dict": return "HashMap<_, _>"
        if gul_type == "set": return "HashSet<_>"
        if gul_type == "tuple": return "(_)"
        return gul_type

# Public API
fn generate_rust_code(program: Program) -> @str:
    """Generate Rust code from GUL AST"""
    var generator = CodeGenerator.create()
    generator.generate_program(program)
    return generator.get_output()
