# GUL v3.2 Compiler - Rust Code Generator
# Transpiles GUL AST to Rust code

@imp std.collections
@imp std.io
@imp compiler.ast.nodes

# Code generator state
struct CodeGenerator:
    output: @list[@str]  # Lines of generated Rust code
    indent_level: @int
    
    fn create() -> CodeGenerator:
        return CodeGenerator{
            output: @list[],
            indent_level: @int(0)
        }
    
impl CodeGenerator:
    fn indent(ref self):
        """Increase indentation level"""
        self.indent_level = self.indent_level + 1
    
    fn dedent(ref self):
        """Decrease indentation level"""
        if self.indent_level > 0:
            self.indent_level = self.indent_level - 1
    
    fn emit(ref self, code: @str):
        """Emit a line of code with current indentation"""
        let indent_str = "    " * self.indent_level
        self.output.add(indent_str + code)
    
    fn emit_raw(ref self, code: @str):
        """Emit code without indentation"""
        self.output.add(code)
    
    fn get_output(self) -> @str:
        """Get generated code as string"""
        return "\n".join(self.output)
    
    # ========================================
    # PROGRAM GENERATION
    # ========================================
    
    fn generate_program(ref self, program: Program):
        """Generate code for entire program"""
        # Emit standard imports
        self.emit_raw("// Generated by GUL compiler")
        self.emit_raw("")
        
        # Generate imports
        for import_stmt in program.imports:
            self.generate_import(import_stmt)
        
        if len(program.imports) > 0:
            self.emit_raw("")
        
        # Generate statements
        for stmt in program.statements:
            self.generate_statement(stmt)
        
        # Generate main entry point
        if len(program.main_entry) > 0:
            self.emit_raw("")
            self.emit("fn main() {")
            self.indent()
            for stmt in program.main_entry:
                self.generate_statement(stmt)
            self.dedent()
            self.emit("}")
    
    # ========================================
    # STATEMENT GENERATION
    # ========================================
    
    fn generate_statement(ref self, stmt: Statement):
        let st = stmt.stmt_type
        if st == StmtType.LetDecl: self.generate_let(stmt)
        elif st == StmtType.VarDecl: self.generate_var(stmt)
        elif st == StmtType.FunctionDecl: self.generate_function(stmt)
        elif st == StmtType.IfStmt: self.generate_if(stmt)
        elif st == StmtType.WhileStmt: self.generate_while(stmt)
        elif st == StmtType.ForStmt: self.generate_for(stmt)
        elif st == StmtType.ReturnStmt: self.generate_return(stmt)
        elif st == StmtType.AssignmentStmt: self.generate_assignment(stmt)
        elif st == StmtType.ExpressionStmt: self.generate_expression_stmt(stmt)
    fn generate_let(ref self, stmt: LetStmt):
        """Generate let declaration"""
        var code = "let " + stmt.name
        if stmt.type_annotation: code = code + ": " + self.map_type(stmt.type_annotation)
        code = code + " = " + self.generate_expression_str(stmt.value) + ";"
        self.emit(code)
    
    fn generate_var(ref self, stmt: VarStmt):
        """Generate var declaration (mutable)"""
        var code = "let mut " + stmt.name
        if stmt.type_annotation: code = code + ": " + self.map_type(stmt.type_annotation)
        code = code + " = " + self.generate_expression_str(stmt.value) + ";"
        self.emit(code)
    
    fn generate_function(ref self, stmt: FunctionDecl):
        """Generate function declaration"""
        var signature = "fn " + stmt.name + "("
        var params = @list[]
        for param in stmt.parameters:
            var param_str = param.name
            if param.type_annotation: param_str = param_str + ": " + self.map_type(param.type_annotation)
            params.add(param_str)
        signature = signature + ", ".join(params) + ")"
        if stmt.return_type: signature = signature + " -> " + self.map_type(stmt.return_type)
        signature = signature + " {"
        self.emit(signature)
        self.indent()
        for body_stmt in stmt.body: self.generate_statement(body_stmt)
        self.dedent()
        self.emit("}")
        self.emit_raw("")
    
    fn generate_if(ref self, stmt: IfStmt):
        """Generate if statement"""
        let condition = self.generate_expression_str(stmt.condition)
        self.emit("if " + condition + " {")
        
        self.indent()
        for s in stmt.then_body:
            self.generate_statement(s)
        self.dedent()
        
        # Elif clauses
        for elif_clause in stmt.elif_clauses:
            let elif_cond = self.generate_expression_str(elif_clause.condition)
            self.emit("} else if " + elif_cond + " {")
            self.indent()
            for s in elif_clause.body:
                self.generate_statement(s)
            self.dedent()
        
        # Else clause
        if len(stmt.else_body) > 0:
            self.emit("} else {")
            self.indent()
            for s in stmt.else_body:
                self.generate_statement(s)
            self.dedent()
        
        self.emit("}")
    
    fn generate_while(ref self, stmt: WhileStmt):
        """Generate while loop"""
        let condition = self.generate_expression_str(stmt.condition)
        self.emit("while " + condition + " {")
        
        self.indent()
        for s in stmt.body:
            self.generate_statement(s)
        self.dedent()
        self.emit("}")
    
    fn generate_for(ref self, stmt: ForStmt):
        """Generate for loop"""
        let iterable = self.generate_expression_str(stmt.iterable)
        self.emit("for " + stmt.variable + " in " + iterable + " {")
        
        self.indent()
        for s in stmt.body:
            self.generate_statement(s)
        self.dedent()
        self.emit("}")
    
    fn generate_return(ref self, stmt: ReturnStmt):
        """Generate return statement"""
        if stmt.value:
            let value = self.generate_expression_str(stmt.value)
            self.emit("return " + value + ";")
        else:
            self.emit("return;")
    
    fn generate_assignment(ref self, stmt: AssignmentStmt):
        """Generate assignment"""
        let target = self.generate_expression_str(stmt.target)
        let value = self.generate_expression_str(stmt.value)
        
        # Handle compound assignments
        var op = "="
        if stmt.operator == TokenType.PlusEq:
            op = "+="
        elif stmt.operator == TokenType.MinusEq:
            op = "-="
        elif stmt.operator == TokenType.StarEq:
            op = "*="
        elif stmt.operator == TokenType.SlashEq:
            op = "/="
        
        self.emit(target + " " + op + " " + value + ";")
    
    fn generate_expression_stmt(ref self, stmt: ExpressionStmt):
        """Generate expression statement"""
        let expr = self.generate_expression_str(stmt.expression)
        self.emit(expr + ";")
    
    fn generate_import(ref self, stmt: ImportStmt):
        """Generate import (as Rust use statement)"""
        let module = "::".join(stmt.module_path)
        
        if len(stmt.items) > 0:
            let items = ", ".join(items)
            self.emit_raw("use " + module + "::{" + items + "};")
        else:
            self.emit_raw("use " + module + ";")
    
    # ========================================
    # EXPRESSION GENERATION
    # ========================================
    
    fn generate_expression_str(ref self, expr: Expression) -> @str:
        let et = expr.expr_type
        if et == ExprType.IntegerLiteral: return self.generate_literal(@cast(LiteralExpr, expr))
        if et == ExprType.FloatLiteral: return self.generate_literal(@cast(LiteralExpr, expr))
        if et == ExprType.StringLiteral: return self.generate_string_literal(@cast(LiteralExpr, expr))
        if et == ExprType.BooleanLiteral: return self.generate_literal(@cast(LiteralExpr, expr))
        if et == ExprType.Identifier: return self.generate_identifier(@cast(IdentifierExpr, expr))
        if et == ExprType.BinaryOp: return self.generate_binary_op(@cast(BinaryOpExpr, expr))
        if et == ExprType.UnaryOp: return self.generate_unary_op(@cast(UnaryOpExpr, expr))
        if et == ExprType.Call: return self.generate_call(@cast(CallExpr, expr))
        if et == ExprType.Index: return self.generate_index(@cast(IndexExpr, expr))
        if et == ExprType.Attribute: return self.generate_attribute(@cast(AttributeExpr, expr))
        if et == ExprType.ListLiteral: return self.generate_list(@cast(ListExpr, expr))
        if et == ExprType.TupleLiteral: return self.generate_tuple(@cast(TupleExpr, expr))
        if et == ExprType.SetLiteral: return self.generate_set(@cast(SetExpr, expr))
        if et == ExprType.DictLiteral: return self.generate_dict(@cast(DictExpr, expr))
        if et == ExprType.TypeConstructor: return self.generate_type_constructor(@cast(TypeConstructorExpr, expr))
        return "/* unsupported expression */"
    
    fn generate_literal(ref self, expr: LiteralExpr) -> @str:
        """Generate literal value"""
        return expr.value
    
    fn generate_string_literal(ref self, expr: LiteralExpr) -> @str:
        """Generate string literal with quotes"""
        return "\"" + expr.value + "\""
    
    fn generate_identifier(ref self, expr: IdentifierExpr) -> @str:
        """Generate identifier"""
        return expr.name
    
    fn generate_binary_op(ref self, expr: BinaryOpExpr) -> @str:
        let left = self.generate_expression_str(expr.left)
        let right = self.generate_expression_str(expr.right)
        let op_t = expr.operator
        var op = ""
        if op_t == TokenType.Plus: op = "+"
        elif op_t == TokenType.Minus: op = "-"
        elif op_t == TokenType.Star: op = "*"
        elif op_t == TokenType.Slash: op = "/"
        elif op_t == TokenType.Percent: op = "%"
        elif op_t == TokenType.DoubleStar: return left + ".pow(" + right + ")"
        elif op_t == TokenType.EqualEqual: op = "=="
        elif op_t == TokenType.NotEqual: op = "!="
        elif op_t == TokenType.Less: op = "<"
        elif op_t == TokenType.Greater: op = ">"
        elif op_t == TokenType.LessEq: op = "<="
        elif op_t == TokenType.GreaterEq: op = ">="
        elif op_t == TokenType.And: op = "&&"
        elif op_t == TokenType.Or: op = "||"
        elif op_t == TokenType.DotDot: return left + ".." + right
        elif op_t == TokenType.DotDotEq: return left + "..=" + right
        else: op = "?"
        return "(" + left + " " + op + " " + right + ")"
    
    fn generate_unary_op(ref self, expr: UnaryOpExpr) -> @str:
        """Generate unary operation"""
        let operand = self.generate_expression_str(expr.operand)
        
        if expr.operator == TokenType.Minus:
            return "-" + operand
        elif expr.operator == TokenType.Not:
            return "!" + operand
        else:
            return "?" + operand
    
    fn generate_call(ref self, expr: CallExpr) -> @str:
        """Generate function call"""
        let callee = self.generate_expression_str(expr.callee)
        
        var args = @list[]
        for arg in expr.arguments:
            args.add(self.generate_expression_str(arg))
        
        let args_str = ", ".join(args)
        return callee + "(" + args_str + ")"
    
    fn generate_index(ref self, expr: IndexExpr) -> @str:
        """Generate index operation"""
        let object = self.generate_expression_str(expr.object)
        let index = self.generate_expression_str(expr.index)
        return object + "[" + index + "]"
    
    fn generate_attribute(ref self, expr: AttributeExpr) -> @str:
        """Generate attribute access"""
        let object = self.generate_expression_str(expr.object)
        return object + "." + expr.attribute
    
    fn generate_list(ref self, expr: ListExpr) -> @str:
        """Generate list literal"""
        var elements = @list[]
        for elem in expr.elements:
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements)
        return "vec![" + elems_str + "]"
    
    fn generate_tuple(ref self, expr: TupleExpr) -> @str:
        """Generate tuple literal"""
        var elements = @list[]
        for elem in expr.elements:
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements)
        return "(" + elems_str + ")"
    
    fn generate_set(ref self, expr: SetExpr) -> @str:
        """Generate set literal"""
        var elements = @list[]
        for elem in expr.elements:
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements)
        return "HashSet::from([" + elems_str + "])"
    
    fn generate_dict(ref self, expr: DictExpr) -> @str:
        """Generate dictionary literal"""
        var pairs = @list[]
        for pair in expr.pairs:
            let key = self.generate_expression_str(pair[0])
            let value = self.generate_expression_str(pair[1])
            pairs.add("(" + key + ", " + value + ")")
        
        let pairs_str = ", ".join(pairs)
        return "HashMap::from([" + pairs_str + "])"
    
    fn generate_type_constructor(ref self, expr: TypeConstructorExpr) -> @str:
        """Generate type constructor/cast"""
        let arg = self.generate_expression_str(expr.argument)
        
        match expr.type_name:
            "int" => return "(" + arg + " as i64)"
            "float" => return "(" + arg + " as f64)"
            "str" => return "(" + arg + ".to_string())"
            "bool" => return "(" + arg + " as bool)"
            _ => return arg + " /* " + expr.type_name + " */"
    
    # ========================================
    # TYPE MAPPING
    # ========================================
    
    fn map_type(self, gul_type: @str) -> @str:
        if gul_type == "int": return "i64"
        if gul_type == "float": return "f64"
        if gul_type == "str": return "String"
        if gul_type == "bool": return "bool"
        if gul_type == "list": return "Vec<_>"
        if gul_type == "dict": return "HashMap<_, _>"
        if gul_type == "set": return "HashSet<_>"
        if gul_type == "tuple": return "(_)"
        return gul_type

# Public API
fn generate_rust_code(program: Program) -> @str:
    """Generate Rust code from GUL AST"""
    var generator = CodeGenerator.create()
    generator.generate_program(program)
    return generator.get_output()
