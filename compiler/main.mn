# GUL v3.2 Compiler - Main Driver
# Integrates lexer, parser, semantic analyzer, and code generator

@imp std.io
@imp std.fs
@imp compiler.lexer.lexer
@imp compiler.parser.parser
@imp compiler.semantic.analyzer
@imp compiler.codegen.rust_backend

# print("COMPILER MODULES LOADED")

# Compiler configuration
struct CompilerConfig:
    input_file: @str
    output_file: @str
    emit_rust: @bool
    check_semantics: @bool
    verbose: @bool

# Compiler result
struct CompileResult:
    success: @bool
    output_code: @str
    errors: @list[@str]
    warnings: @list[@str]

# Main compiler
struct Compiler:
    config: CompilerConfig

fn create_compiler(config: CompilerConfig) -> Compiler:
    return Compiler{config: config}

fn compiler_read_source_file(compiler: Compiler) -> @str:
    """Read source file contents"""
    try:
        return read_file(compiler.config.input_file)
    catch e:
        print("Error reading file: " + str(e))
        return ""

fn compiler_write_output_file(compiler: Compiler, code: @str):
    """Write generated code to output file"""
    try:
        write_file(compiler.config.output_file, code)
        if compiler.config.verbose:
            print("Generated code written to " + compiler.config.output_file)
    catch e:
        print("Error writing file: " + str(e))

fn compiler_create_result(success: @bool, code: @str, errors: @list[@str], warnings: @list[@str]) -> CompileResult:
    """Create compile result"""
    return CompileResult{success: success, output_code: code, errors: errors, warnings: warnings}

fn compiler_compile(compiler: Compiler) -> CompileResult:
    """Compile GUL source file"""
    var errors = @list[]
    var warnings = @list[]
    
    let source = compiler_read_source_file(compiler)
    if not source:
        errors.add("Failed to read source file")
        return compiler_create_result(@bool(false), "", errors, warnings)
    
    print("  [1/4] Lexing...")
    let tokens = tokenize(source)
    print("    Lexed " + str(len(tokens)) + " tokens")
    
    print("  [2/4] Parsing...")
    let ast = parse_with_tokens(tokens)
    
    # TODO: Check parser errors
    
    # Phase 3: Semantic Analysis
    if compiler.config.check_semantics:
        if compiler.config.verbose:
            print("  [3/4] Semantic analysis...")
        
        let semantic_errors = analyze_semantics(ast)
        errors.extend(semantic_errors)
        
        if len(semantic_errors) > 0:
            return compiler_create_result(@bool(false), "", errors, warnings)
    
    print("  [3/4] Semantic analysis...")
    analyze_semantics(ast)
    
    print("  [4/4] Generating Rust code...")
    let rust_code = generate_rust_code(ast)
    
    if compiler.config.verbose:
        print("Debug: Generated Rust code length: " + len(rust_code))
    print("FORCE DEBUG: Rust code length: " + len(rust_code))
    if len(rust_code) > 0:
        print("Debug: Rust code preview:")
        print(rust_code)
            
    # Write output file
    if compiler.config.emit_rust:
        compiler_write_output_file(compiler, rust_code)
    
    if compiler.config.verbose:
        print("Compilation successful!")
    
    return compiler_create_result(@bool(true), rust_code, errors, warnings)

# CLI interface
fn compile_file(input_file: @str, output_file: @str, options: @dict) -> CompileResult:
    print("ENTER compile_file")
    """Compile a GUL file to Rust"""
    let config = CompilerConfig{input_file: input_file, output_file: output_file, emit_rust: options.get("emit_rust", @bool(true)), check_semantics: options.get("check_semantics", @bool(true)), verbose: options.get("verbose", @bool(false))}
    
    var compiler = create_compiler(config)
    let result = compiler_compile(compiler)
    print("DEBUG: Result success: " + str(result.success))
    print("DEBUG: Result fields: " + str(result.fields))
    return result

# Main entry point for compiler
mn:
    # Parse command-line arguments
    let args = sys.argv
    
    # Default values
    var input_file = ""
    var output_file = ""
    var verbose = @bool(false)
    var check_semantics = @bool(true)
    
    # Simple argument parsing
    if len(args) < 2:
        print("GUL Compiler v0.1.0")
        print("Usage: gul-compile <input.mn> [options]")
        print("Options:")
        print("  -o <file>      Output file (default: input.rs)")
        print("  --verbose      Verbose output")
        print("  --no-semantic  Skip semantic analysis")
        return
    
    input_file = args[1]
    
    # Parse options
    var i = 2
    while i < len(args):
        let arg = args[i]
        if arg == "-o":
            if i + 1 < len(args):
                output_file = args[i + 1]
                i = i + 2
        elif arg == "--verbose":
            verbose = @bool(true)
            i = i + 1
        elif arg == "--no-semantic":
            check_semantics = @bool(false)
            i = i + 1
        else:
            i = i + 1
    
    # Default output file
    if output_file == "":
        output_file = input_file.replace(".mn", ".rs")
    
    # Compile
    let result = compile_file(input_file, output_file, @dict{"emit_rust": @bool(true), "check_semantics": check_semantics, "verbose": verbose})
    
    if result.success:
        print("Compilation successful!")
        if len(result.warnings) > 0:
            print("Warnings: " + str(len(result.warnings)))
    else:
        print("Compilation failed!")
        # Use simple prints to debug structure
        print("DEBUG: Result fields available? (Check interpreter debug)")
        # Flattened access
        let errs = result.errors
        print("DEBUG: errors var type: " + str(type(errs)))
        if errs:
             print("Errors list length: " + len(errs))
             for error in errs:
                print("  " + error)
        else:
             print("Result.errors is None or empty")
