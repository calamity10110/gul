// Vulnerability Scanner for Package Registry
// Integrates with OSV.dev and provides security scanning

use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String,
    pub summary: String,
    pub severity: Severity,
    pub affected_versions: Vec<String>,
    pub fixed_in: Option<String>,
    pub published: String,
    pub references: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize, PartialEq)]
pub enum Severity {
    Critical,
    High,
    Medium,
    Low,
    Unknown,
}

pub struct VulnerabilityScanner {
    // In production: OSV API client, NVD client
    vulnerability_db: HashMap<String, Vec<Vulnerability>>,
}

impl VulnerabilityScanner {
    pub fn new() -> Self {
        Self {
            vulnerability_db: HashMap::new(),
        }
    }

    /// Scan a package for known vulnerabilities
    pub async fn scan_package(&self, name: &str, version: &str) -> Vec<Vulnerability> {
        // In production: Query OSV.dev API
        // GET https://api.osv.dev/v1/query
        // {
        //   "package": {"name": "package-name", "ecosystem": "GUL"},
        //   "version": "1.0.0"
        // }

        let key = format!("{}@{}", name, version);
        self.vulnerability_db.get(&key).cloned().unwrap_or_default()
    }

    /// Scan package dependencies recursively
    pub async fn scan_dependencies(
        &self,
        dependencies: &HashMap<String, String>,
    ) -> HashMap<String, Vec<Vulnerability>> {
        let mut results = HashMap::new();

        for (name, version) in dependencies {
            let vulns = self.scan_package(name, version).await;
            if !vulns.is_empty() {
                results.insert(name.clone(), vulns);
            }
        }

        results
    }

    /// Add vulnerability to database (for testing)
    pub fn add_vulnerability(&mut self, package: String, vuln: Vulnerability) {
        self.vulnerability_db.entry(package).or_default().push(vuln);
    }

    /// Check if package has critical vulnerabilities
    pub async fn has_critical_vulns(&self, name: &str, version: &str) -> bool {
        let vulns = self.scan_package(name, version).await;
        vulns.iter().any(|v| v.severity == Severity::Critical)
    }

    /// Get vulnerability summary
    pub async fn get_summary(&self, name: &str, version: &str) -> VulnerabilitySummary {
        let vulns = self.scan_package(name, version).await;

        VulnerabilitySummary {
            total: vulns.len(),
            critical: vulns
                .iter()
                .filter(|v| v.severity == Severity::Critical)
                .count(),
            high: vulns
                .iter()
                .filter(|v| v.severity == Severity::High)
                .count(),
            medium: vulns
                .iter()
                .filter(|v| v.severity == Severity::Medium)
                .count(),
            low: vulns.iter().filter(|v| v.severity == Severity::Low).count(),
        }
    }
}

impl Default for VulnerabilityScanner {
    fn default() -> Self {
        Self::new()
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VulnerabilitySummary {
    pub total: usize,
    pub critical: usize,
    pub high: usize,
    pub medium: usize,
    pub low: usize,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_scan_package() {
        let mut scanner = VulnerabilityScanner::new();

        let vuln = Vulnerability {
            id: "CVE-2024-1234".to_string(),
            summary: "Critical security issue".to_string(),
            severity: Severity::Critical,
            affected_versions: vec!["1.0.0".to_string()],
            fixed_in: Some("1.0.1".to_string()),
            published: "2024-01-01".to_string(),
            references: vec!["https://example.com/advisory".to_string()],
        };

        scanner.add_vulnerability("test-pkg@1.0.0".to_string(), vuln);

        let results = scanner.scan_package("test-pkg", "1.0.0").await;
        assert_eq!(results.len(), 1);
        assert_eq!(results[0].id, "CVE-2024-1234");
    }

    #[tokio::test]
    async fn test_has_critical_vulns() {
        let mut scanner = VulnerabilityScanner::new();

        let vuln = Vulnerability {
            id: "CVE-2024-5678".to_string(),
            summary: "Critical issue".to_string(),
            severity: Severity::Critical,
            affected_versions: vec!["1.0.0".to_string()],
            fixed_in: Some("1.0.1".to_string()),
            published: "2024-01-01".to_string(),
            references: vec![],
        };

        scanner.add_vulnerability("vuln-pkg@1.0.0".to_string(), vuln);

        assert!(scanner.has_critical_vulns("vuln-pkg", "1.0.0").await);
        assert!(!scanner.has_critical_vulns("safe-pkg", "1.0.0").await);
    }

    #[tokio::test]
    async fn test_vulnerability_summary() {
        let mut scanner = VulnerabilityScanner::new();

        scanner.add_vulnerability(
            "pkg@1.0.0".to_string(),
            Vulnerability {
                id: "CVE-1".to_string(),
                summary: "Critical".to_string(),
                severity: Severity::Critical,
                affected_versions: vec![],
                fixed_in: None,
                published: "2024-01-01".to_string(),
                references: vec![],
            },
        );

        scanner.add_vulnerability(
            "pkg@1.0.0".to_string(),
            Vulnerability {
                id: "CVE-2".to_string(),
                summary: "High".to_string(),
                severity: Severity::High,
                affected_versions: vec![],
                fixed_in: None,
                published: "2024-01-01".to_string(),
                references: vec![],
            },
        );

        let summary = scanner.get_summary("pkg", "1.0.0").await;
        assert_eq!(summary.total, 2);
        assert_eq!(summary.critical, 1);
        assert_eq!(summary.high, 1);
    }
}
