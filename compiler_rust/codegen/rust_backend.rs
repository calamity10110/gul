// Auto-generated from GUL source
#![allow(unused_variables, dead_code, unused_mut)]

use std::collections::{HashMap, HashSet, VecDeque};

// GUL v3.2 Compiler - Rust Code Generator
// Transpiles GUL AST to Rust code

use std::collections;
use std::io;
use compiler::ast::nodes;

// Code generator state
struct CodeGenerator {
    output: @list[@str]  # Lines of generated Rust code
    indent_level: @int
    
fn create() -> CodeGenerator {
        return CodeGenerator{
            output: @list[],
            indent_level: @int(0)
        }
    
fn indent(&mut &self) {
        """Increase indentation level"""
        self.indent_level = self.indent_level + 1
    
fn dedent(&mut &self) {
        """Decrease indentation level"""
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1
    
fn emit(&mut &self, code { String):
        """Emit a line of code with current indentation"""
        let indent_str = "    " * self.indent_level;
        self.output.add(indent_str + code)
    
fn emit_raw(&mut &self, code { String):
        """Emit code without indentation"""
        self.output.add(code)
    
fn get_output(&self) -> String {
        """Get generated code as string"""
        return "\n".join(self.output)
    
    // ========================================
    // PROGRAM GENERATION
    // ========================================
    
fn generate_program(&mut &self, program { Program):
        """Generate code for entire program"""
        // Emit standard imports
        self.emit_raw("// Generated by GUL compiler")
        self.emit_raw("")
        
        // Generate imports
        for import_stmt in program.imports {
            self.generate_import(import_stmt)
        
        if len(program.imports) > 0 {
            self.emit_raw("")
        
        // Generate statements
        for stmt in program.statements {
            self.generate_statement(stmt)
        
        // Generate main entry point
        if len(program.main_entry) > 0 {
            self.emit_raw("")
            self.emit("fn main() {")
            self.indent()
            for stmt in program.main_entry {
                self.generate_statement(stmt)
            self.dedent()
            self.emit("}")
    
    // ========================================
    // STATEMENT GENERATION
    // ========================================
    
fn generate_statement(&mut &self, stmt { Statement):
        """Generate code for a statement"""
        match stmt.stmt_type {
            StmtType.LetDecl => self.generate_let(stmt)
            StmtType.VarDecl => self.generate_var(stmt)
            StmtType.FunctionDecl => self.generate_function(stmt)
            StmtType.IfStmt => self.generate_if(stmt)
            StmtType.WhileStmt => self.generate_while(stmt)
            StmtType.ForStmt => self.generate_for(stmt)
            StmtType.ReturnStmt => self.generate_return(stmt)
            StmtType.AssignmentStmt => self.generate_assignment(stmt)
            StmtType.ExpressionStmt => self.generate_expression_stmt(stmt)
            StmtType.ImportStmt => pass  # Already handled
            _ => pass
fn generate_let(&mut &self, stmt { LetStmt):
        """Generate let declaration"""
        let mut code = String(format!("let {stmt.name}"));
        
        if stmt.type_annotation {
            code = code + format!(": {self.map_type(stmt.type_annotation)}")
        
        code = code + " = " + self.generate_expression_str(stmt.value) + ";"
        self.emit(code)
    
fn generate_var(&mut &self, stmt { VarStmt):
        """Generate var declaration (mutable)"""
        let mut code = String(format!("let mut {stmt.name}"));
        
        if stmt.type_annotation {
            code = code + format!(": {self.map_type(stmt.type_annotation)}")
        
        code = code + " = " + self.generate_expression_str(stmt.value) + ";"
        self.emit(code)
    
fn generate_function(&mut &self, stmt { FunctionDecl):
        """Generate function declaration"""
        let mut signature = String("fn {stmt.name}(");
        
        // Parameters
        let mut params = Vec[];
        for param in stmt.parameters {
            let mut param_str = param.name;
            if param.type_annotation {
                param_str = param_str + format!(": {self.map_type(param.type_annotation)}")
            params.add(param_str)
        
        signature = signature + ", ".join(params) + ")"
        
        // Return type
        if stmt.return_type {
            signature = signature + format!(" -> {self.map_type(stmt.return_type)}")
        
        signature = signature + " {"
        self.emit(signature)
        
        // Body
        self.indent()
        for body_stmt in stmt.body {
            self.generate_statement(body_stmt)
        self.dedent()
        self.emit("}")
        self.emit_raw("")
    
fn generate_if(&mut &self, stmt { IfStmt):
        """Generate if statement"""
        let condition = self.generate_expression_str(stmt.condition);
        self.emit(format!("if {condition} {{"))
        
        self.indent()
        for s in stmt.then_body {
            self.generate_statement(s)
        self.dedent()
        
        // Elif clauses
        for elif_clause in stmt.elif_clauses {
            let elif_cond = self.generate_expression_str(elif_clause.condition);
            self.emit(format!("}} else if {elif_cond} {{"))
            self.indent()
            for s in elif_clause.body {
                self.generate_statement(s)
            self.dedent()
        
        // Else clause
        if len(stmt.else_body) > 0 {
            self.emit("} else {")
            self.indent()
            for s in stmt.else_body {
                self.generate_statement(s)
            self.dedent()
        
        self.emit("}")
    
fn generate_while(&mut &self, stmt { WhileStmt):
        """Generate while loop"""
        let condition = self.generate_expression_str(stmt.condition);
        self.emit(format!("while {condition} {{"))
        
        self.indent()
        for s in stmt.body {
            self.generate_statement(s)
        self.dedent()
        self.emit("}")
    
fn generate_for(&mut &self, stmt { ForStmt):
        """Generate for loop"""
        let iterable = self.generate_expression_str(stmt.iterable);
        self.emit(format!("for {stmt.variable} in {iterable} {{"))
        
        self.indent()
        for s in stmt.body {
            self.generate_statement(s)
        self.dedent()
        self.emit("}")
    
fn generate_return(&mut &self, stmt { ReturnStmt):
        """Generate return statement"""
        if stmt.value {
            let value = self.generate_expression_str(stmt.value);
            self.emit(format!("return {value};"))
        else {
            self.emit("return;")
    
fn generate_assignment(&mut &self, stmt { AssignmentStmt):
        """Generate assignment"""
        let target = self.generate_expression_str(stmt.target);
        let value = self.generate_expression_str(stmt.value);
        
        // Handle compound assignments
        let mut op = "=";
        if stmt.operator == TokenType.PlusEq {
            op = "+="
        else if stmt.operator == TokenType.MinusEq {
            op = "-="
        else if stmt.operator == TokenType.StarEq {
            op = "*="
        else if stmt.operator == TokenType.SlashEq {
            op = "/="
        
        self.emit(format!("{target} {op} {value};"))
    
fn generate_expression_stmt(&mut &self, stmt { ExpressionStmt):
        """Generate expression statement"""
        let expr = self.generate_expression_str(stmt.expression);
        self.emit(format!("{expr};"))
    
fn generate_import(&mut &self, stmt { ImportStmt):
        """Generate import (as Rust use statement)"""
        let module = "::".join(stmt.module_path);
        
        if len(stmt.items) > 0 {
            let items = ", ".join(stmt.items);
            self.emit_raw(format!("use {module}::{{{items}}};"))
        else {
            self.emit_raw(format!("use {module};"))
    
    // ========================================
    // EXPRESSION GENERATION
    // ========================================
    
fn generate_expression_str(&mut &self, expr { Expression) -> String:
        """Generate code for expression, return as string"""
        match expr.expr_type {
            ExprType.IntegerLiteral => return self.generate_literal(expr)
            ExprType.FloatLiteral => return self.generate_literal(expr)
            ExprType.StringLiteral => return self.generate_string_literal(expr)
            ExprType.BooleanLiteral => return self.generate_literal(expr)
            ExprType.Identifier => return self.generate_identifier(expr)
            ExprType.BinaryOp => return self.generate_binary_op(expr)
            ExprType.UnaryOp => return self.generate_unary_op(expr)
            ExprType.Call => return self.generate_call(expr)
            ExprType.Index => return self.generate_index(expr)
            ExprType.Attribute => return self.generate_attribute(expr)
            ExprType.ListLiteral => return self.generate_list(expr)
            ExprType.TupleLiteral => return self.generate_tuple(expr)
            ExprType.SetLiteral => return self.generate_set(expr)
            ExprType.DictLiteral => return self.generate_dict(expr)
            ExprType.TypeConstructor => return self.generate_type_constructor(expr)
            _ => return "/* unsupported expression */"
    
fn generate_literal(&mut &self, expr { LiteralExpr) -> String:
        """Generate literal value"""
        return expr.value
    
fn generate_string_literal(&mut &self, expr { LiteralExpr) -> String:
        """Generate string literal with quotes"""
        return f'"{expr.value}"'
    
fn generate_identifier(&mut &self, expr { IdentifierExpr) -> String:
        """Generate identifier"""
        return expr.name
    
fn generate_binary_op(&mut &self, expr { BinaryOpExpr) -> String:
        """Generate binary operation"""
        let left = self.generate_expression_str(expr.left);
        let right = self.generate_expression_str(expr.right);
        
        let mut op = "";
        match expr.operator {
            TokenType.Plus => op = "+"
            TokenType.Minus => op = "-"
            TokenType.Star => op = "*"
            TokenType.Slash => op = "/"
            TokenType.Percent => op = "%"
            TokenType.DoubleStar => op = ".pow"  # Rust uses pow method
            TokenType.EqualEqual => op = "=="
            TokenType.NotEqual => op = "!="
            TokenType.Less => op = "<"
            TokenType.Greater => op = ">"
            TokenType.LessEq => op = "<="
            TokenType.GreaterEq => op = ">="
            TokenType.And => op = "&&"
            TokenType.Or => op = "||"
            TokenType.DotDot => return format!("{left}..{right}")
            TokenType.DotDotEq => return format!("{left}..={right}")
            _ => op = "?"
        
        if expr.operator == TokenType.DoubleStar {
            // Special case for power
            return format!("{left}.pow({right})")
        else {
            return format!("({left} {op} {right})")
    
fn generate_unary_op(&mut &self, expr { UnaryOpExpr) -> String:
        """Generate unary operation"""
        let operand = self.generate_expression_str(expr.operand);
        
        if expr.operator == TokenType.Minus {
            return format!("-{operand}")
        else if expr.operator == TokenType.Not {
            return format!("!{operand}")
        else {
            return format!("?{operand}")
    
fn generate_call(&mut &self, expr { CallExpr) -> String:
        """Generate function call"""
        let callee = self.generate_expression_str(expr.callee);
        
        let mut args = Vec[];
        for arg in expr.arguments {
            args.add(self.generate_expression_str(arg))
        
        let args_str = ", ".join(args);
        return format!("{callee}({args_str})")
    
fn generate_index(&mut &self, expr { IndexExpr) -> String:
        """Generate index operation"""
        let object = self.generate_expression_str(expr.object);
        let index = self.generate_expression_str(expr.index);
        return format!("{object}[{index}]")
    
fn generate_attribute(&mut &self, expr { AttributeExpr) -> String:
        """Generate attribute access"""
        let object = self.generate_expression_str(expr.object);
        return format!("{object}.{expr.attribute}")
    
fn generate_list(&mut &self, expr { ListExpr) -> String:
        """Generate list literal"""
        let mut elements = Vec[];
        for elem in expr.elements {
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements);
        return format!("vec![{elems_str}]")
    
fn generate_tuple(&mut &self, expr { TupleExpr) -> String:
        """Generate tuple literal"""
        let mut elements = Vec[];
        for elem in expr.elements {
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements);
        return format!("({elems_str})")
    
fn generate_set(&mut &self, expr { SetExpr) -> String:
        """Generate set literal"""
        let mut elements = Vec[];
        for elem in expr.elements {
            elements.add(self.generate_expression_str(elem))
        
        let elems_str = ", ".join(elements);
        return format!("HashSet::from([{elems_str}])")
    
fn generate_dict(&mut &self, expr { DictExpr) -> String:
        """Generate dictionary literal"""
        let mut pairs = Vec[];
        for pair in expr.pairs {
            let key = self.generate_expression_str(pair[0]);
            let value = self.generate_expression_str(pair[1]);
            pairs.add(format!("({key}, {value})"))
        
        let pairs_str = ", ".join(pairs);
        return format!("HashMap::from([{pairs_str}])")
    
fn generate_type_constructor(&mut &self, expr { TypeConstructorExpr) -> String:
        """Generate type constructor/cast"""
        let arg = self.generate_expression_str(expr.argument);
        
        match expr.type_name {
            "int" => return format!("({arg} as i64)")
            "float" => return format!("({arg} as f64)")
            "str" => return format!("({arg}.to_string())")
            "bool" => return format!("({arg} as bool)")
            _ => return format!("{arg} /* {expr.type_name} */")
    
    // ========================================
    // TYPE MAPPING
    // ========================================
    
fn map_type(&self, gul_type { String) -> String:
        """Map GUL type to Rust type"""
        match gul_type {
            "int" => return "i64"
            "float" => return "f64"
            "str" => return "String"
            "bool" => return "bool"
            "list" => return "Vec<_>"
            "dict" => return "HashMap<_, _>"
            "set" => return "HashSet<_>"
            "tuple" => return "(_)"
            _ => return gul_type  # Pass through unknown types

// Public API
fn generate_rust_code(program { Program) -> String:
    """Generate Rust code from GUL AST"""
    let mut generator = CodeGenerator.create();
    generator.generate_program(program)
    return generator.get_output()
