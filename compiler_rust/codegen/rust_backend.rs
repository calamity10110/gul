// GUL v3.2 Compiler - Rust Code Generator
// Transpiles GUL AST to Rust code

use std::collections::{HashMap, HashSet};
use std::io;
use crate::ast::nodes::*;
use crate::lexer::token::*;

// Code generator state
#[derive(Debug, Clone, PartialEq)]
pub struct CodeGenerator {
    pub output: Vec<String>, // Lines of generated Rust code
    pub indent_level: usize,

}
impl CodeGenerator {
    pub fn create()  ->  CodeGenerator {
        return CodeGenerator {
            output: vec![],
            indent_level: 0usize,
        };

    }
    pub fn indent(&mut self) {

        // Increase indentation level// 
        self.indent_level = self.indent_level + 1;

    }
    pub fn dedent(&mut self) {
        // Decrease indentation level// 
        if self.indent_level > 0 {
            self.indent_level = self.indent_level - 1;

        }
    }
    pub fn emit(&mut self, code: String) {
        // Emit a line of code with current indentation// 
        let indent_str = "    ".to_string().repeat(self.indent_level);
        self.output.push(format!("{}{}", indent_str, code));

    }
    pub fn emit_raw(&mut self, code: String) {
        // Emit code without indentation// 
        self.output.push(code);

    }
    pub fn get_output(&self)  ->  String {
        // Get generated code as string// 
        return "\n".to_string().join(self.output);

    // ========================================
    // PROGRAM GENERATION
    // ========================================

    }
    pub fn generate_program(&mut self, program: Program) {
        // Generate code for entire program// 
        // Emit standard imports
        self.emit_raw("// Generated by GUL compiler".to_string().to_string());
        self.emit_raw("");

        // Generate imports
        for import_stmt in program.imports {
            self.generate_import(import_stmt);

        }
        if (program.imports).len() > 0 {
            self.emit_raw("");

        // Generate statements
        }
        for stmt in program.statements {
            self.generate_statement(stmt);

        // Generate main entry point
        }
        if (program.main_entry).len() > 0 {
            self.emit_raw("");
            self.emit("fn main() {".to_string().to_string());
            self.indent();
            for stmt in program.main_entry {
                self.generate_statement(stmt);
            }
            self.dedent();
            self.emit("}".to_string().to_string());

    // ========================================
    // STATEMENT GENERATION
    // ========================================

        }
    }
    pub fn generate_statement(&mut self, stmt: &Statement) {
        match stmt {
            Statement::LetDecl(s) => self.generate_let(s),
            Statement::VarDecl(s) => self.generate_var(s),
            Statement::FunctionDecl(s) => self.generate_function(s),
            Statement::IfStmt(s) => self.generate_if(s),
            Statement::WhileStmt(s) => self.generate_while(s),
            Statement::ForStmt(s) => self.generate_for(s),
            Statement::ReturnStmt(s) => self.generate_return(s),
            Statement::AssignmentStmt(s) => self.generate_assignment(s),
            Statement::ExpressionStmt(s) => self.generate_expression_stmt(s),
            Statement::StructDecl(s) => self.emit("// Struct decl".to_string().to_string()), // TODO
            Statement::EnumDecl(s) => self.emit("// Enum decl".to_string().to_string()), // TODO
            Statement::ImportStmt(s) => self.generate_import(s),
            Statement::PassStmt(s) => {}
            _ => self.emit_raw("// Unsupported statement".to_string().to_string()),
        }
    }
    pub fn generate_let(&mut self, stmt: &LetStmt) {
        // Generate let declaration// 
        let mut code = format!("let {}", stmt.name);
        if stmt.type_annotation { code = format!("{}: {}", code, self.map_type(stmt.type_annotation)) }
        code = format!("{} = {};", code, self.generate_expression_str(stmt.value));
        self.emit(code);

    }
    pub fn generate_var(&mut self, stmt: &VarStmt) {
        // Generate var declaration (mutable)// 
        let mut code = format!("let mut {}", stmt.name);
        if stmt.type_annotation { code = format!("{}: {}", code, self.map_type(stmt.type_annotation)) }
        code = format!("{} = {};", code, self.generate_expression_str(stmt.value));
        self.emit(code);

    }
    pub fn generate_function(&mut self, stmt: &FunctionDecl) {
        // Generate function declaration// 
        let mut signature = format!("fn {}(", stmt.name);
        let mut params = vec![];
        for param in &stmt.parameters {
            let mut param_str = param.name;
            if param.type_annotation { param_str = format!("{}: {}", param_str, self.map_type(param.type_annotation)) }
            params.push(param_str);
        }
        signature = signature + params.join(", ") + ".to_string())";
        if stmt.return_type { signature = format!("{} -> {}", signature, self.map_type(stmt.return_type)) }
        signature = signature + " {";
        self.emit(signature);
        self.indent();
        for body_stmt in &stmt.body { self.generate_statement(body_stmt) }
        self.dedent();
        self.emit("}".to_string().to_string());
        self.emit_raw("");

    }
    pub fn generate_if(&mut self, stmt: &IfStmt) {
        // Generate if statement// 
        let condition = self.generate_expression_str(stmt.condition);
        self.emit(format!("if {}", condition) + " {");

        self.indent();
        for s in &stmt.then_body {
            self.generate_statement(s);
        }
        self.dedent();

        // Elif clauses
        for elif_clause in &stmt.elif_clauses {
            let elif_cond = self.generate_expression_str(elif_clause.condition);
            self.emit("} else if ".to_string() + &format!("{}", elif_cond) + " {");
            self.indent();
            for s in &elif_clause.body {
                self.generate_statement(s);
            }
            self.dedent();

        // Else clause
        }
        if (stmt.else_body).len() > 0 {
            self.emit("} else {".to_string().to_string());
            self.indent();
            for s in &stmt.else_body {
                self.generate_statement(s);
            }
            self.dedent();

        }
        self.emit("}".to_string().to_string());

    }
    pub fn generate_while(&mut self, stmt: &WhileStmt) {
        // Generate while loop// 
        let condition = self.generate_expression_str(stmt.condition);
        self.emit(format!("while {}", condition) + " {");

        self.indent();
        for s in &stmt.body {
            self.generate_statement(s);
        }
        self.dedent();
        self.emit("}".to_string().to_string());

    }
    pub fn generate_for(&mut self, stmt: &ForStmt) {
        // Generate for loop// 
        let iterable = self.generate_expression_str(stmt.iterable);
        self.emit(format!("for {} in {}", stmt.variable, iterable) + " {");

        self.indent();
        for s in &stmt.body {
            self.generate_statement(s);
        }
        self.dedent();
        self.emit("}".to_string().to_string());

    }
    pub fn generate_return(&mut self, stmt: &ReturnStmt) {
        // Generate return statement// 
        if stmt.value {
            let value = self.generate_expression_str(stmt.value);
            self.emit(format!("return {};", value));
        }
        else {
            self.emit("return;".to_string().to_string());

        }
    }
    pub fn generate_assignment(&mut self, stmt: &AssignmentStmt) {
        // Generate assignment// 
        let target = self.generate_expression_str(stmt.target);
        let value = self.generate_expression_str(stmt.value);

        // Handle compound assignments
        let mut op = "=".to_string();
        if stmt.operator == TokenType::PlusEq {
            op = "+=".to_string();
        }
        else if stmt.operator == TokenType::MinusEq {
            op = "-=".to_string();
        }
        else if stmt.operator == TokenType::StarEq {
            op = "*=".to_string();
        }
        else if stmt.operator == TokenType::SlashEq {
            op = "/=".to_string();

        }
        self.emit(format!("{} {} {};", target, op, value));

    }
    pub fn generate_expression_stmt(&mut self, stmt: &ExpressionStmt) {
        // Generate expression statement// 
        let expr = self.generate_expression_str(stmt.expression);
        self.emit(expr + ";");

    }
    pub fn generate_import(&mut self, stmt: &ImportStmt) {
        // Generate import (as Rust use statement)// 
        let module = "::".to_string().join(stmt.module_path);

        if (stmt.items).len() > 0 {
            let items = ", ".to_string().join(items);
            self.emit_raw("use ".to_string() + module + "::{".to_string() + &items + "};");
        }
        else {
            self.emit_raw("use ".to_string() + module + ";");

    // ========================================
    // EXPRESSION GENERATION
    // ========================================

        }
    }
    pub fn generate_expression_str(&mut self, expr: &Expression)  ->  String {
        match expr {
            Expression::Literal(lit) =>
                if lit.value_type == TokenType::StringLiteral { return self.generate_string_literal(lit) }
                else { return self.generate_literal(lit) }
            Expression::Identifier(id) => return self.generate_identifier(id),
            Expression::BinaryOp(op) => return self.generate_binary_op(op),
            Expression::UnaryOp(op) => return self.generate_unary_op(op),
            Expression::Call(call) => return self.generate_call(call),
            Expression::Index(idx) => return self.generate_index(idx),
            Expression::Attribute(attr) => return self.generate_attribute(attr),
            Expression::List(l) => return self.generate_list(l),
            Expression::Tuple(t) => return self.generate_tuple(t),
            Expression::Set(s) => return self.generate_set(s),
            Expression::Dict(d) => return self.generate_dict(d),
            Expression::Lambda(l) => return "lambda_todo".to_string(),
            Expression::Match(m) => return "match_todo".to_string(),
            Expression::Grouped(g) => return "(".to_string() + self.generate_expression_str(g.expression) + ".to_string().to_string())",
            _ => return "unknown_expr".to_string(),
        }
        return "/* unsupported expression */".to_string();

    }
    pub fn generate_literal(&mut self, expr: LiteralExpr)  ->  String {
        // Generate literal value// 
        return expr.value;

    }
    pub fn generate_string_literal(&mut self, expr: LiteralExpr)  ->  String {
        // Generate string literal with quotes// 
        return "\".to_string()".to_string() + &expr.value + "\"";

    }
    pub fn generate_identifier(&mut self, expr: &IdentifierExpr)  ->  String {
        // Generate identifier// 
        return expr.name;

    }
    pub fn generate_binary_op(&mut self, expr: &BinaryOpExpr)  ->  String {
        let left = self.generate_expression_str(expr.left);
        let right = self.generate_expression_str(expr.right);
        let op_t = expr.operator;
        let mut op = "";

        if op_t == TokenType::Plus { op = "+".to_string() }
        else if op_t == TokenType::Minus { op = "-".to_string() }
        else if op_t == TokenType::Star { op = "*".to_string() }
        else if op_t == TokenType::Slash { op = "/".to_string() }
        else if op_t == TokenType::Percent { op = "%".to_string() }
        else if op_t == TokenType::DoubleStar { return format!("{}.pow({})", left, right) }
        else if op_t == TokenType::EqualEqual { op = "==".to_string() }
        else if op_t == TokenType::NotEqual { op = "!=".to_string() }
        else if op_t == TokenType::Greater { op = ">".to_string() }
        else if op_t == TokenType::Less { op = "<".to_string() }
        else if op_t == TokenType::GreaterEq { op = ">=".to_string() }
        else if op_t == TokenType::LessEq { op = "<=".to_string() }
        else if op_t == TokenType::And { op = "&&".to_string() }
        else if op_t == TokenType::Or { op = "||".to_string() }
        else if op_t == TokenType::DotDot { return format!("{}..{}", left, right) }
        else if op_t == TokenType::DotDotEq { return format!("{}..={}", left, right) }
        else { op = "?".to_string() }
        return format!("({} {} {})", left, op, right);

    }
    pub fn generate_unary_op(&mut self, expr: &UnaryOpExpr)  ->  String {
        // Generate unary operation// 
        let operand = self.generate_expression_str(expr.operand);

        if expr.operator == TokenType::Minus {
            return format!("-{}", operand);
        }
        else if expr.operator == TokenType::Not {
            return format!("!{}", operand);
        }
        else {
            return format!("?{}", operand.to_string());

        }
    }
    pub fn generate_call(&mut self, expr: &CallExpr)  ->  String {
        // Generate function call// 
        let callee = self.generate_expression_str(expr.callee);

        let mut args = vec![];
        for arg in &expr.arguments {
            args.push(self.generate_expression_str(arg));

        }
        let args_str = ", ".to_string().join(args);
        return format!("{}({})", callee, args_str);

    }
    pub fn generate_index(&mut self, expr: &IndexExpr)  ->  String {
        // Generate index operation// 
        let object = self.generate_expression_str(expr.object);
        let index = self.generate_expression_str(expr.index);
        return format!("{}[{}]", object, index);

    }
    pub fn generate_attribute(&mut self, expr: &AttributeExpr)  ->  String {
        // Generate attribute access// 
        let object = self.generate_expression_str(expr.object);
        return format!("{}.{}", object, expr.attribute);

    }
    pub fn generate_list(&mut self, expr: &ListExpr)  ->  String {
        // Generate list literal// 
        let mut elements = vec![];
        for elem in &expr.elements {
            elements.push(self.generate_expression_str(elem));

        }
        let elems_str = ", ".to_string().join(elements);
        return format!("vec![{}]", elems_str);

    }
    pub fn generate_tuple(&mut self, expr: &TupleExpr)  ->  String {
        // Generate tuple literal// 
        let mut elements = vec![];
        for elem in &expr.elements {
            elements.push(self.generate_expression_str(elem));

        }
        let elems_str = ", ".to_string().join(elements);
        return format!("({})", elems_str);

    }
    pub fn generate_set(&mut self, expr: &SetExpr)  ->  String {
        // Generate set literal// 
        let mut elements = vec![];
        for elem in &expr.elements {
            elements.push(self.generate_expression_str(elem));

        }
        let elems_str = ", ".to_string().join(elements);
        return format!("HashSet::from([{}])", elems_str);

    }
    pub fn generate_dict(&mut self, expr: &DictExpr)  ->  String {
        // Generate dictionary literal// 
        let mut pairs = vec![];
        for pair in &expr.pairs {
            let key = self.generate_expression_str(pair[0]);
            let value = self.generate_expression_str(pair[1]);
            pairs.push(format!("({}, {})", key, value));

        }
        let pairs_str = ", ".to_string().join(pairs);
        return format!("HashMap::from([{}])", pairs_str);

    }
    pub fn generate_type_constructor(&mut self, expr: &TypeConstructorExpr)  ->  String {
        // Generate type constructor/cast// 
        let arg = self.generate_expression_str(expr.argument);

        match expr.type_name {
            "int" => return format!("({} as i64)", arg),
            "float" => return format!("({} as f64)", arg),
            "str" => return format!("({}.to_string())", arg),
            "bool" => return format!("({} as bool)", arg),
            _ => return format!("{} /* {} */", arg, expr.type_name),

    // ========================================
    // TYPE MAPPING
    // ========================================

        }
    }
    pub fn map_type(&self, gul_type: String)  ->  String {
        if gul_type == "int".to_string() { return "i64".to_string() }
        if gul_type == "float".to_string() { return "f64".to_string() }
        if gul_type == "str".to_string() { return "String".to_string() }
        if gul_type == "bool".to_string() { return "bool".to_string() }
        if gul_type == "list".to_string() { return "Vec<_>".to_string() }
        if gul_type == "dict".to_string() { return "HashMap<_, _>".to_string() }
        if gul_type == "set".to_string() { return "HashSet<_>".to_string() }
        if gul_type == "tuple".to_string() { return "(_)".to_string() }
        return gul_type;

// Public API
    }
}
pub fn generate_rust_code(program: Program)  ->  String {
    // Generate Rust code from GUL AST// 
    let mut generator = CodeGenerator.create();
    generator.generate_program(program);
    return generator.get_output();
}