// Code generator - generates target code from AST

use crate::ast::*;

pub struct CodeGenerator {
    target: String,
    output: String,
    indent_level: usize,
}

impl CodeGenerator {
    pub fn new(target: String) -> Self {
        CodeGenerator {
            target,
            output: String::new(),
            indent_level: 0,
        }
    }

    pub fn generate(&mut self, program: &Program) -> Result<String, String> {
        self.output.clear();

        // Generate header
        self.generate_header();

        // Generate statements
        for statement in &program.statements {
            self.generate_statement(statement)?;
        }

        Ok(self.output.clone())
    }

    fn generate_header(&mut self) {
        match self.target.as_str() {
            "native" => {
                self.emit_line("// Generated by Universal Language Compiler");
                self.emit_line("");
            }
            "wasm" => {
                self.emit_line(";; Generated by Universal Language Compiler");
                self.emit_line("");
            }
            _ => {}
        }
    }

    fn generate_statement(&mut self, statement: &Statement) -> Result<(), String> {
        match statement {
            Statement::Import(modules) => {
                for module in modules {
                    self.emit_line(&format!("// import {}", module));
                }
            }
            Statement::StructDef {
                name,
                fields,
                methods,
            } => {
                self.emit_line(&format!("struct {} {{", name));
                self.indent();
                for (field_name, field_type) in fields {
                    self.emit_line(&format!("{}: {},", field_name, field_type));
                }
                self.dedent();
                self.emit_line("}");

                if !methods.is_empty() {
                    self.emit_line(&format!("impl {} {{", name));
                    self.indent();
                    for method in methods {
                        self.generate_statement(method)?;
                    }
                    self.dedent();
                    self.emit_line("}");
                }
            }
            Statement::Definition { name, value } => {
                let value_code = self.generate_expression(value)?;
                self.emit_line(&format!("let {} = {};", name, value_code));
            }
            Statement::Function {
                name,
                params,
                outputs,
                body,
                is_async,
            } => {
                let async_keyword = if *is_async { "async " } else { "" };
                let params_str = params.iter().map(|(n, _)| n.clone()).collect::<Vec<String>>().join(", ");
                let outputs_str = if outputs.is_empty() {
                    "".to_string()
                } else {
                    format!("({}) ", outputs.iter().map(|(n, _)| n.clone()).collect::<Vec<String>>().join(", "))
                };
                self.emit_line(&format!("{}fn {}({}) {} {{", async_keyword, name, params_str, outputs_str));
                self.indent();

                for stmt in body {
                    self.generate_statement(stmt)?;
                }

                self.dedent();
                self.emit_line("}");
            }
            Statement::Main { body } => {
                self.emit_line("fn main() {");
                self.indent();

                for stmt in body {
                    self.generate_statement(stmt)?;
                }

                self.dedent();
                self.emit_line("}");
            }
            Statement::If {
                condition,
                then_body,
                else_body,
            } => {
                let cond_code = self.generate_expression(condition)?;
                self.emit_line(&format!("if {} {{", cond_code));
                self.indent();

                for stmt in then_body {
                    self.generate_statement(stmt)?;
                }

                self.dedent();

                if let Some(else_stmts) = else_body {
                    self.emit_line("} else {");
                    self.indent();

                    for stmt in else_stmts {
                        self.generate_statement(stmt)?;
                    }

                    self.dedent();
                }

                self.emit_line("}");
            }
            Statement::Loop { body } => {
                self.emit_line("loop {");
                self.indent();

                for stmt in body {
                    self.generate_statement(stmt)?;
                }

                self.dedent();
                self.emit_line("}");
            }
            Statement::For {
                variable,
                iterable,
                body,
                is_parallel: _,
            } => {
                let iter_code = self.generate_expression(iterable)?;
                self.emit_line(&format!("for {} in {} {{", variable, iter_code));
                self.indent();

                for stmt in body {
                    self.generate_statement(stmt)?;
                }

                self.dedent();
                self.emit_line("}");
            }
            Statement::While {
                condition,
                body,
                is_parallel,
            } => {
                let parallel_marker = if *is_parallel { "/* parallel */ " } else { "" };
                let cond_code = self.generate_expression(condition)?;
                self.emit_line(&format!("{}while {} {{", parallel_marker, cond_code));
                self.indent();

                for stmt in body {
                    self.generate_statement(stmt)?;
                }

                self.dedent();
                self.emit_line("}");
            }
            Statement::Return(expr) => {
                if let Some(e) = expr {
                    let expr_code = self.generate_expression(e)?;
                    self.emit_line(&format!("return {};", expr_code));
                } else {
                    self.emit_line("return;");
                }
            }
            Statement::Break => {
                self.emit_line("break;");
            }
            Statement::Continue => {
                self.emit_line("continue;");
            }
            Statement::Assignment { name, value } => {
                let value_code = self.generate_expression(value)?;
                self.emit_line(&format!("{} = {};", name, value_code));
            }
            Statement::Expression(expr) => {
                let expr_code = self.generate_expression(expr)?;
                self.emit_line(&format!("{};", expr_code));
            }
            Statement::ForeignBlock { language, code } => {
                self.emit_line(&format!("// Foreign {} block:", language));
                self.emit_line(&format!("// {}", code));
            }
            Statement::GlobalDef { name, value, .. } => {
                // Treat global as normal definition for now in codegen
                let val_code = self.generate_expression(value)?;
                self.emit_line(&format!("// Global {}", name));
                self.emit_line(&format!("let {} = {};", name, val_code));
            }
            Statement::Try { .. } => {
                self.emit_line("// Try/catch not implemented in codegen yet");
            }
            Statement::Throw(expr) => {
                let expr_code = self.generate_expression(expr)?;
                self.emit_line(&format!("throw {};", expr_code));
            }
        }

        Ok(())
    }

    fn generate_expression(&mut self, expr: &Expression) -> Result<String, String> {
        match expr {
            Expression::Integer(n) => Ok(n.to_string()),
            Expression::Float(f) => Ok(f.to_string()),
            Expression::String(s) => Ok(format!("\"{}\"", s)),
            Expression::Bool(b) => Ok(b.to_string()),
            Expression::Identifier(name) => Ok(name.clone()),
            Expression::Binary { left, op, right } => {
                let left_code = self.generate_expression(left)?;
                let right_code = self.generate_expression(right)?;
                let op_str = self.binary_op_to_string(op);
                Ok(format!("({} {} {})", left_code, op_str, right_code))
            }
            Expression::Unary { op, operand } => {
                let operand_code = self.generate_expression(operand)?;
                let op_str = self.unary_op_to_string(op);
                Ok(format!("({}{})", op_str, operand_code))
            }
            Expression::Call { function, args } => {
                let func_code = self.generate_expression(function)?;
                let args_code: Result<Vec<_>, _> =
                    args.iter().map(|a| self.generate_expression(a)).collect();
                let args_code = args_code?;
                Ok(format!("{}({})", func_code, args_code.join(", ")))
            }
            Expression::Member { object, member } => {
                let obj_code = self.generate_expression(object)?;
                Ok(format!("{}.{}", obj_code, member))
            }
            Expression::Index { object, index } => {
                let obj_code = self.generate_expression(object)?;
                let idx_code = self.generate_expression(index)?;
                Ok(format!("{}[{}]", obj_code, idx_code))
            }
            Expression::List(elements) => {
                let elem_codes: Result<Vec<_>, _> = elements
                    .iter()
                    .map(|e| self.generate_expression(e))
                    .collect();
                let elem_codes = elem_codes?;
                Ok(format!("[{}]", elem_codes.join(", ")))
            }
            Expression::Dict(pairs) => {
                let pair_codes: Result<Vec<String>, String> = pairs
                    .iter()
                    .map(|(k, v)| {
                        let v_code = self.generate_expression(v)?;
                        Ok(format!("\"{}\": {}", k, v_code))
                    })
                    .collect();
                let pair_codes = pair_codes?;
                Ok(format!("{{{}}}", pair_codes.join(", ")))
            }
            Expression::UiSprite { sprite_type, .. } => {
                Ok(format!("UiSprite(\"{}\")", sprite_type))
            }
            Expression::Await(expr) => {
                let expr_code = self.generate_expression(expr)?;
                Ok(format!("await {}", expr_code))
            }
            Expression::Ownership { value, .. } => self.generate_expression(value),
            Expression::ListOp { .. } => Ok("/* list op */".to_string()),
            Expression::Typed { expr, .. } => self.generate_expression(expr), // For now, ignore type annotation in codegen
            Expression::Lambda { .. } => Ok("/* lambda */".to_string()), // Placeholder for lambda
        }
    }

    fn binary_op_to_string(&self, op: &BinaryOp) -> &'static str {
        match op {
            BinaryOp::Add => "+",
            BinaryOp::Subtract => "-",
            BinaryOp::Multiply => "*",
            BinaryOp::Divide => "/",
            BinaryOp::Modulo => "%",
            BinaryOp::Power => "**",
            BinaryOp::Equal => "==",
            BinaryOp::NotEqual => "!=",
            BinaryOp::Less => "<",
            BinaryOp::LessEqual => "<=",
            BinaryOp::Greater => ">",
            BinaryOp::GreaterEqual => ">=",
            BinaryOp::And => "&&",
            BinaryOp::Or => "||",
        }
    }

    fn unary_op_to_string(&self, op: &UnaryOp) -> &'static str {
        match op {
            UnaryOp::Negate => "-",
            UnaryOp::Not => "!",
        }
    }

    fn emit_line(&mut self, line: &str) {
        let indent = "    ".repeat(self.indent_level);
        self.output.push_str(&format!("{}{}\n", indent, line));
    }

    fn indent(&mut self) {
        self.indent_level += 1;
    }

    fn dedent(&mut self) {
        if self.indent_level > 0 {
            self.indent_level -= 1;
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generate_simple_definition() {
        let mut generator = CodeGenerator::new("native".to_string());

        let program = Program {
            statements: vec![Statement::Definition {
                name: "x".to_string(),
                value: Expression::Integer(42),
            }],
        };

        let code = generator.generate(&program).unwrap();
        assert!(code.contains("let x = 42;"));
    }

    #[test]
    fn test_generate_function() {
        let mut generator = CodeGenerator::new("native".to_string());

        let program = Program {
            statements: vec![Statement::Function {
                name: "add".to_string(),
                params: vec!["a".to_string(), "b".to_string()],
                body: vec![Statement::Return(Some(Expression::Binary {
                    left: Box::new(Expression::Identifier("a".to_string())),
                    op: BinaryOp::Add,
                    right: Box::new(Expression::Identifier("b".to_string())),
                }))],
                is_async: false,
            }],
        };

        let code = generator.generate(&program).unwrap();
        assert!(code.contains("fn add(a, b)"));
        assert!(code.contains("return (a + b);"));
    }

    #[test]
    fn test_generate_if_statement() {
        let mut generator = CodeGenerator::new("native".to_string());

        let program = Program {
            statements: vec![Statement::If {
                condition: Expression::Bool(true),
                then_body: vec![Statement::Expression(Expression::Integer(1))],
                else_body: Some(vec![Statement::Expression(Expression::Integer(2))]),
            }],
        };

        let code = generator.generate(&program).unwrap();
        assert!(code.contains("if true"));
        assert!(code.contains("} else {"));
    }
}
