# GUL Compiler Integration Tests
# Tests core language features using v2.1 syntax

import std{testing}

# ==========================================
# Test 1: Bracket Equivalence
# ==========================================

@test
fn test_bracket_equivalence_function_calls():
    """All bracket types work for function calls"""
    
    # These should all be equivalent
    r1 = to_string(42)
    r2 = to_string[42]
    r3 = to_string{42}
    
    assert r1 == r2
    assert r2 == r3
    assert r1 == "42"

@test
fn test_bracket_equivalence_collections():
    """All bracket types work for collections"""
    
    # List with different brackets
    list1 = [1, 2, 3]
    list2 = (1, 2, 3)
    list3 = {1, 2, 3}
    
    assert len(list1) == 3
    assert len(list2) == 3
    assert len(list3) == 3

@test
fn test_bracket_equivalence_parameters():
    """All bracket types work for named parameters"""
    
    config1 = {host: "localhost", port: 8080}
    config2 = [host: "localhost", port: 8080]
    config3 = (host: "localhost", port: 8080)
    
    assert config1["host"] == "localhost"
    assert config2["port"] == 8080

@test
fn test_mixed_bracket_nesting():
    """Mixed brackets work when each pair matches"""
    
    # Nested with different bracket types
    data = [
        {name: "Alice", scores: (90, 85, 92)},
        (name: "Bob", scores: [88, 91, 87])
    ]
    
    assert len(data) == 2
    assert data[0]["name"] == "Alice"

# ==========================================
# Test 2: UI Component Syntax
# ==========================================

@test
fn test_ui_component_literal():
    """Test ^&^ component literal syntax"""
    
    # Component literal
    component = ^&^[button{text: "Click"}]
    
    assert component.type == "button"
    assert component.props["text"] == "Click"

@test
fn test_ui_print_function():
    """Test ui.print() function style"""
    
    # Function style (equivalent to ^&^)
    ui.print(button[text: "Click"])
    ui.print(table{data: [1, 2, 3]})
    
    # ^&^() and ui.print() are the same
    ^&^[label{text: "Hello"}]
    ui.print(label[text: "Hello"])

@test
fn test_ui_component_equivalence():
    """^&^ and ui.print() produce same result"""
    
    # These are equivalent
    c1 = ^&^[button{text: "A"}]
    c2 = ui.component(button[text: "A"])
    
    assert c1.type == c2.type
    assert c1.props["text"] == c2.props["text"]

# ==========================================
# Test 3: File Type Syntax
# ==========================================

@test
fn test_main_block_syntax():
    """Test main block without parentheses"""
    
    # Valid syntax: main: (no parentheses)
    # main:
    #     print("Hello")
    
    assert True  # Syntax is tested by compilation

@test
fn test_import_syntax():
    """Test import brace syntax"""
    
    # import std{io, http}  - imports io and http from std
    import std{math}
    
    result = math.sqrt(16)
    assert result == 4.0

# ==========================================
# Test 4: Function Definition Syntax
# ==========================================

@test
fn test_function_bracket_flexibility():
    """Functions can use any matching brackets"""
    
    fn add_parens(a: int, b: int): int:
        return a + b
    
    fn add_brackets[a: int, b: int]: int:
        return a + b
    
    fn add_braces{a: int, b: int}: int:
        return a + b
    
    assert add_parens(2, 3) == 5
    assert add_brackets[2, 3] == 5
    assert add_braces{2, 3} == 5

@test
fn test_async_function_syntax():
    """Async functions with new syntax"""
    
    async fetch_data[url: str]:
        # async without 'fn' keyword
        response = await http.get(url)
        return response.json()
    
    async fn fetch_data2(url: str):
        # async with 'fn' keyword (also valid)
        return await http.get(url)

# ==========================================
# Test 5: Type and Struct Definitions
# ==========================================

@test
fn test_struct_definition():
    """Test struct definition syntax"""
    
    struct Point:
        x: float
        y: float
        
        fn distance(self): float:
            return math.sqrt(self.x^2 + self.y^2)
    
    p = Point{x: 3.0, y: 4.0}
    assert p.distance() == 5.0

@test
fn test_struct_with_different_brackets():
    """Struct instantiation with any brackets"""
    
    struct User:
        name: str
        age: int
    
    u1 = User{name: "Alice", age: 30}
    u2 = User[name: "Bob", age: 25]
    u3 = User(name: "Charlie", age: 35)
    
    assert u1.name == "Alice"
    assert u2.name == "Bob"
    assert u3.name == "Charlie"

# ==========================================
# Run All Tests
# ==========================================

main:
    print("Running GUL v2.1 Compiler Tests...")
    testing.run_all_tests()
    print("All tests passed!")
