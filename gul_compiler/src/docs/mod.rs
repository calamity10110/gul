// Automatic Syntax Documentation Generator
// Extracts patterns from GUL source and generates human/LLM-readable syntax.md

use anyhow::Result;
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fs;

#[derive(Debug, Serialize, Deserialize)]
struct SyntaxPattern {
    category: String,
    pattern: String,
    example: String,
    description: String,
}

pub struct SyntaxExtractor {
    patterns: HashMap<String, Vec<SyntaxPattern>>,
}

impl SyntaxExtractor {
    pub fn new() -> Self {
        SyntaxExtractor {
            patterns: HashMap::new(),
        }
    }

    pub fn extract_from_source(&mut self, source: &str) -> Result<()> {
        // Parse source and extract patterns
        for line in source.lines() {
            let trimmed = line.trim();
            
            if trimmed.starts_with("fn ") {
                self.add_pattern(
                    "Functions",
                    "fn <name>(<params>) -> <type>:",
                    line.to_string(),
                    "Function declaration".to_string(),
                );
            } else if trimmed.starts_with("let ") {
                self.add_pattern(
                    "Variables",
                    "let <name> = <value>",
                    line.to_string(),
                    "Immutable variable".to_string(),
                );
            } else if trimmed.starts_with("var ") {
                self.add_pattern(
                    "Variables",
                    "var <name> = <value>",
                    line.to_string(),
                    "Mutable variable".to_string(),
                );
            } else if trimmed.starts_with("struct ") {
                self.add_pattern(
                    "Types",
                    "struct <name>:",
                    line.to_string(),
                    "Structure definition".to_string(),
                );
            } else if trimmed.starts_with("enum ") {
                self.add_pattern(
                    "Types",
                    "enum <name>:",
                    line.to_string(),
                    "Enumeration definition".to_string(),
                );
            } else if trimmed.starts_with("if ") {
                self.add_pattern(
                    "Control Flow",
                    "if <condition>:",
                    line.to_string(),
                    "Conditional statement".to_string(),
                );
            } else if trimmed.starts_with("while ") {
                self.add_pattern(
                    "Control Flow",
                    "while <condition>:",
                    line.to_string(),
                    "While loop".to_string(),
                );
            } else if trimmed.starts_with("for ") {
                self.add_pattern(
                    "Control Flow",
                    "for <var> in <iterable>:",
                    line.to_string(),
                    "For loop".to_string(),
                );
            } else if trimmed.starts_with("@") && trimmed.contains("(") {
                self.add_pattern(
                    "Decorators",
                    "@<decorator>",
                    line.to_string(),
                    "Decorator/annotation".to_string(),
                );
            } else if trimmed.contains("@int") || trimmed.contains("@str") || trimmed.contains("@bool") {
                self.add_pattern(
                    "Type Annotations",
                    "@<type>",
                    line.to_string(),
                    "Type annotation".to_string(),
                );
            }
        }
        
        Ok(())
    }

    fn add_pattern(&mut self, category: &str, pattern: &str, example: String, description: String) {
        let patterns = self.patterns.entry(category.to_string()).or_insert_with(Vec::new);
        
        // Avoid duplicates
        if !patterns.iter().any(|p| p.pattern == pattern && p.example == example) {
            patterns.push(SyntaxPattern {
                category: category.to_string(),
                pattern: pattern.to_string(),
                example,
                description,
            });
        }
    }

    pub fn generate_markdown(&self) -> String {
        let mut md = String::from("# GUL Syntax Reference\n\n");
        md.push_str("*Auto-generated from source code patterns*\n\n");
        md.push_str("---\n\n");

        for (category, patterns) in &self.patterns {
            md.push_str(&format!("## {}\n\n", category));
            
            for pattern in patterns {
                md.push_str(&format!("### {}\n\n", pattern.description));
                md.push_str(&format!("**Pattern:** `{}`\n\n", pattern.pattern));
                md.push_str("**Example:**\n```gul\n");
                md.push_str(&pattern.example);
                md.push_str("\n```\n\n");
            }
        }

        md.push_str("---\n\n");
        md.push_str("*Generated by GUL Compiler*\n");
        
        md
    }
}

pub fn generate_syntax_md(input_path: &str, output_path: &str) -> Result<()> {
    let source = fs::read_to_string(input_path)?;
    
    let mut extractor = SyntaxExtractor::new();
    extractor.extract_from_source(&source)?;
    
    let markdown = extractor.generate_markdown();
    
    let syntax_path = if output_path.ends_with('/') {
        format!("{}syntax.md", output_path)
    } else {
        "syntax.md".to_string()
    };
    
    fs::write(&syntax_path, markdown)?;
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_pattern_extraction() {
        let source = r#"
fn main():
    let x = 42
    var y = "hello"
    if x > 0:
        print(y)
"#;
        
        let mut extractor = SyntaxExtractor::new();
        extractor.extract_from_source(source).unwrap();
        
        let md = extractor.generate_markdown();
        assert!(md.contains("Functions"));
        assert!(md.contains("Variables"));
        assert!(md.contains("Control Flow"));
    }
}
