# GUL v3.1 Showcase - Complete Syntax Examples
# This file demonstrates all v3.1 syntax features

# ============================================
# 1. IMPORTS - @imp syntax
# ============================================

@imp std.io
@imp std.http
@imp std.math
@imp python{numpy, pandas}
@imp rust{tokio, serde}

# Block-style imports
@imp:
    std.json,
    std.crypto,
    std.time

# ============================================
# 2. VARIABLES - let/var with type annotations
# ============================================

# Immutable (let)
let name = "Alice"
let age = @int(30)
let @float(PI) = 3.14159

# Mutable (var)
var counter = 0
var message = @str("Hello")
var @list(items) = [1, 2, 3]

# ============================================
# 3. FUNCTIONS - Single-line & Multi-line
# ============================================

# Single-line (implicit return - no 'return' keyword)
fn add(a, b): a + b
fn multiply(x, y): x * y
fn greet(name): "Hello, " + name

# Multi-line (explicit return)
fn factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)

fn fibonacci(n):
    if n <= 0:
        return 0
    if n == 1:
        return 1
    return fibonacci(n - 1) + fibonacci(n - 2)

# With explicit types
fn add_typed(@int(a, b)):
    return @int(a + b)

fn concat(@str(s1, s2)):
    return @str(s1 + s2)

# ============================================
# 4. ASYNC FUNCTIONS
# ============================================

# Single-line async (implicit await - no 'await' keyword)
async fetch(url): http.get(url)
async post_data(url, data): http.post(url, data)

# Multi-line async (explicit await)
async fetch_json(url):
    response = await http.get(url)
    return response.json()

async fetch_with_retry(url, retries):
    var attempts = 0
    loop:
        if attempts >= retries:
            return nil
        try:
            await http.get(url)
        catch e:
            attempts = attempts + 1
            await time.sleep(1000)

# ============================================
# 5. BRACKET EQUIVALENCE
# ============================================

# All these are equivalent
fn func1(a, b): a + b
fn func2[a, b]: a + b
fn func3{a, b}: a + b

# Collections with any brackets
let list1 = [1, 2, 3]
let list2 = (1, 2, 3)
let list3 = {1, 2, 3}

# Named parameters with any brackets
let config1 = {host: "localhost", port: 8080}
let config2 = [host: "localhost", port: 8080]
let config3 = (host: "localhost", port: 8080)

# ============================================
# 6. ERROR HANDLING - try/catch/finally
# ============================================

fn safe_divide(a, b):
    try:
        if b == 0:
            throw "Division by zero"
        return a / b
    catch e:
        print("Error:", e)
        return 0
    finally:
        print("Division attempted")

async safe_fetch(url):
    try:
        await http.get(url)
    catch e:
        print("Fetch failed:", e)
        return nil

# ============================================
# 7. CONTROL FLOW
# ============================================

fn classify_number(x):
    if x > 0:
        return "positive"
    elif x < 0:
        return "negative"
    else:
        return "zero"

fn sum_list(items):
    var total = 0
    for item in items:
        total = total + item
    return total

fn countdown(n):
    var i = n
    while i > 0:
        print(i)
        i = i - 1
    print("Done!")

# ============================================
# 8. STRUCTS
# ============================================

struct Point:
    x: @float
    y: @float
    
    fn distance(self):
        return math.sqrt(self.x^2 + self.y^2)

struct User:
    name: @str
    age: @int
    email: @str
    
    fn greet(self): "Hello, " + self.name
    
    fn is_adult(self):
        return self.age >= 18

# ============================================
# 9. FOREIGN CODE BLOCKS
# ============================================

@python {
    import numpy as np
    import pandas as pd
    
    def analyze_data(data):
        arr = np.array(data)
        return {
            "mean": float(np.mean(arr)),
            "std": float(np.std(arr)),
            "min": float(np.min(arr)),
            "max": float(np.max(arr))
        }
}

@rust {
    fn fast_fibonacci(n: u64) -> u64 {
        if n <= 1 { return n; }
        let mut a = 0u64;
        let mut b = 1u64;
        for _ in 2..=n {
            let c = a + b;
            a = b;
            b = c;
        }
        b
    }
}

@sql {
    CREATE TABLE users (
        id INTEGER PRIMARY KEY,
        name TEXT NOT NULL,
        email TEXT UNIQUE,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );
}

# ============================================
# 10. DATA-FLOW (NODE SYSTEM)
# ============================================

node calculate {
    re_in:
        a: borrow @int
        b: move @int
    re_out:
        sum: @int
        product: @int
}

# Simple pipeline
mn: [
    input(5) -> double -> print
]

# Complex pipeline
mn: [
    read_file("data.csv")
        -> parse_csv
        -> filter(row: row.age > 18)
        -> transform(row: row.name.upper())
        -> write_file("output.csv")
]

# ============================================
# 11. LIST COMPREHENSIONS
# ============================================

let squares = [x^2 for x in range(10)]
let evens = [x for x in range(20) if x % 2 == 0]
let pairs = [(x, y) for x in range(5) for y in range(5)]

# ============================================
# 12. OWNERSHIP MODES
# ============================================

# borrow - mutable access, ownership stays upstream
fn modify_borrowed(data: borrow @list):
    data.append(100)

# ref - read-only access, ownership stays upstream  
fn read_only(data: ref @list):
    return data.length()

# move - ownership transfers to function
fn consume(data: move @list):
    process_and_free(data)

# kept - read-only, ownership transfers
fn keep_ref(data: kept @list):
    store_reference(data)

# ============================================
# MAIN ENTRY POINT
# ============================================

mn:
    print("=== GUL v3.1 Showcase ===")
    
    # Variables
    let x = 10
    var y = 20
    
    # Functions
    print("add(3, 4) =", add(3, 4))
    print("factorial(5) =", factorial(5))
    print("greet('World') =", greet("World"))
    
    # Async
    data = await fetch_json("https://api.example.com/data")
    print("Fetched:", data)
    
    # Structs
    let p = Point{x: 3.0, y: 4.0}
    print("Distance:", p.distance())
    
    let user = User{name: "Alice", age: 25, email: "alice@example.com"}
    print(user.greet())
    
    # Error handling
    result = safe_divide(10, 0)
    print("Safe divide result:", result)
    
    # Foreign code
    stats = python.analyze_data([1, 2, 3, 4, 5])
    print("Stats:", stats)
    
    fib = rust.fast_fibonacci(50)
    print("Fibonacci(50):", fib)
    
    print("=== Demo Complete ===")
