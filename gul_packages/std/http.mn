# HTTP Client Module for GUL v3.1
# Standard library HTTP client with async support

# ============================================
# Types
# ============================================

struct Response:
    status: @int
    headers: @dict
    body: @str
    
    # Single-line methods (implicit return)
    fn ok(self): self.status >= 200 and self.status < 300
    fn text(self): self.body
    
    # Multi-line methods (explicit return)
    fn json(self):
        return std.json.parse(self.body)

struct Request:
    method: @str
    url: @str
    headers: @dict
    body: @str

struct Client:
    base_url: @str
    headers: @dict
    timeout_ms: @int
    
    # Constructor
    fn new(base_url): Client{base_url: base_url, headers: {}, timeout_ms: 30000}
    
    fn with_timeout(self, ms): Client{base_url: self.base_url, headers: self.headers, timeout_ms: ms}
    
    fn with_header(self, key, value):
        var new_headers = self.headers.copy()
        new_headers[key] = value
        return Client{base_url: self.base_url, headers: new_headers, timeout_ms: self.timeout_ms}

# ============================================
# Async HTTP Functions
# ============================================

# Single-line async (implicit await)
async get(url): _http_request("GET", url, {}, nil)
async delete(url): _http_request("DELETE", url, {}, nil)
async head(url): _http_request("HEAD", url, {}, nil)

# Multi-line async (explicit await)
async post(url, data):
    body = std.json.stringify(data)
    headers = {"Content-Type": "application/json"}
    await _http_request("POST", url, headers, body)

async put(url, data):
    body = std.json.stringify(data)
    headers = {"Content-Type": "application/json"}
    await _http_request("PUT", url, headers, body)

async patch(url, data):
    body = std.json.stringify(data)
    headers = {"Content-Type": "application/json"}
    await _http_request("PATCH", url, headers, body)

# Fetch with options
async fetch(url, options):
    method = options.get("method", "GET")
    headers = options.get("headers", {})
    body = options.get("body", nil)
    await _http_request(method, url, headers, body)

# Internal implementation
async _http_request(method, url, headers, body):
    # Native HTTP implementation
    @rust {
        async fn do_request(method: &str, url: &str, headers: HashMap<String, String>, body: Option<String>) -> Response {
            let client = reqwest::Client::new();
            let mut req = client.request(method.parse().unwrap(), url);
            for (k, v) in headers {
                req = req.header(k, v);
            }
            if let Some(b) = body {
                req = req.body(b);
            }
            let resp = req.send().await.unwrap();
            Response {
                status: resp.status().as_u16() as i32,
                headers: HashMap::new(),
                body: resp.text().await.unwrap()
            }
        }
    }
    return await rust.do_request(method, url, headers, body)
