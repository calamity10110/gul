# GUL Standard SIMD Library
# Hardware-accelerated vector operations

# ============================================
# Vec4f - 4-component float vector (SSE/NEON)
# ============================================

struct Vec4f:
    x: flt
    y: flt
    z: flt
    w: flt
    
    fn new(x: flt, y: flt, z: flt, w: flt) -> Vec4f:
        return Vec4f { x: x, y: y, z: z, w: w }
    
    fn zero() -> Vec4f:
        return Vec4f { x: 0.0, y: 0.0, z: 0.0, w: 0.0 }
    
    fn one() -> Vec4f:
        return Vec4f { x: 1.0, y: 1.0, z: 1.0, w: 1.0 }
    
    # Splat: all components same value
    fn splat(v: flt) -> Vec4f:
        return Vec4f { x: v, y: v, z: v, w: v }

# ============================================
# Vector Operations (uses SSE when available)
# ============================================

@extern("gul_simd_add")
fn add(a: Vec4f, b: Vec4f) -> Vec4f

@extern("gul_simd_sub")
fn sub(a: Vec4f, b: Vec4f) -> Vec4f

@extern("gul_simd_mul")
fn mul(a: Vec4f, b: Vec4f) -> Vec4f

@extern("gul_simd_dot")
fn dot(a: Vec4f, b: Vec4f) -> flt

@extern("gul_simd_magnitude")
fn magnitude(v: Vec4f) -> flt

@extern("gul_simd_normalize")
fn normalize(v: Vec4f) -> Vec4f

@extern("gul_simd_cross")
fn cross(a: Vec4f, b: Vec4f) -> Vec4f

# ============================================
# Convenience aliases for 3D vectors
# ============================================

fn vec3(x: flt, y: flt, z: flt) -> Vec4f:
    return Vec4f::new(x, y, z, 0.0)

fn length(v: Vec4f) -> flt:
    return magnitude(v)

fn distance(a: Vec4f, b: Vec4f) -> flt:
    return magnitude(sub(a, b))

fn lerp(a: Vec4f, b: Vec4f, t: flt) -> Vec4f:
    return add(mul(a, Vec4f::splat(1.0 - t)), mul(b, Vec4f::splat(t)))

# ============================================
# Matrix operations (4x4)
# ============================================

struct Mat4:
    # Row-major 4x4 matrix stored as 4 Vec4f rows
    r0: Vec4f
    r1: Vec4f
    r2: Vec4f
    r3: Vec4f
    
    fn identity() -> Mat4:
        return Mat4 {
            r0: Vec4f::new(1.0, 0.0, 0.0, 0.0),
            r1: Vec4f::new(0.0, 1.0, 0.0, 0.0),
            r2: Vec4f::new(0.0, 0.0, 1.0, 0.0),
            r3: Vec4f::new(0.0, 0.0, 0.0, 1.0)
        }
    
    fn zero() -> Mat4:
        return Mat4 {
            r0: Vec4f::zero(),
            r1: Vec4f::zero(),
            r2: Vec4f::zero(),
            r3: Vec4f::zero()
        }
